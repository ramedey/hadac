package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
		Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales (Ejemplo)

terminal Token ABRE_PARENTESIS;
terminal Token ASIGNACION;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CIERRA_PARENTESIS;
terminal Token COMA;
terminal Token CONSTANT;
terminal Token CONSTANTE_CADENA;
terminal Token CONSTANTE_NUMERICA;
terminal Token DECLARACION;
terminal Token PUNTOPUNTO;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IDENTIFICADOR;
terminal Token IGUAL;
terminal Token INTEGER;
terminal Token IN;
terminal Token IF;
terminal Token IS;
terminal Token LOOP;
terminal Token MAYORQUE;
terminal Token OR;
terminal Token PLUS;
terminal Token PROCEDURE;
terminal Token PUNTO;
terminal Token PUNTOYCOMA;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
// ...


// Declaración de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
non terminal            declaraciones, lista_sentencias;
non terminal            dec_const_simbolica, dec_tipo, dec_subprograma;
non terminal ListaIdentificadores lista_identificadores;
non terminal TipoSimple tipo_simple;
non terminal            tipo_registro, tipo_retorno;
non terminal Expresion  expresion, expresion_logica, elemento;
non terminal ExpresionAritmetica expresion_aritmetica;
non terminal            funcion, procedimiento, parametros_formales, parametro_formal, declaraciones_subprograma;
non terminal            acceso_registro, llamada_subprograma, parametros_actuales;
non terminal            sentencia, sentencia_asignacion, sentencia_if, sentencia_for, parametro;
non terminal            sentencia_put_line, resto;
// ...


// Declaración de relaciones de precedencia
precedence left     OR;
precedence left     IGUAL;
precedence left     MAYORQUE;
precedence left     PLUS;
precedence left     PUNTO, ABRE_PARENTESIS, CIERRA_PARENTESIS;
// ...

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Comenzando analisis..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		// Para la entrega de febrero pueden comentarse las dos sentencias siguientes:
  		 List intermediateCode = ax.getIntermediateCode ();
  		 finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest en la entrega de Febrero. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega de Junio deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Proceso de analisis terminado.");
   :};


axiom ::= PROCEDURE IDENTIFICADOR:id ABRE_PARENTESIS CIERRA_PARENTESIS IS declaraciones BEGIN lista_sentencias END IDENTIFICADOR PUNTOYCOMA
        {:
            //Crear el ámbito global del programa asociado al nombre del procedimiento.
            String name = id.getLexema();
            scopeManager.openScope(name);
        :}
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de procedimiento principal."); :};

declaraciones ::= dec_const_simbolica 
                | dec_tipo 
                | dec_subprograma  
                | error declaraciones{: syntaxErrorManager.syntaxDebug ("Error en declaracion."); :}  
                |;

dec_const_simbolica ::= lista_identificadores DECLARACION CONSTANT ASIGNACION CONSTANTE_NUMERICA PUNTOYCOMA declaraciones 
                      | lista_identificadores DECLARACION CONSTANT ASIGNACION TRUE PUNTOYCOMA declaraciones
                      | lista_identificadores DECLARACION CONSTANT ASIGNACION FALSE PUNTOYCOMA declaraciones;

dec_tipo ::= lista_identificadores:lista DECLARACION tipo_simple:tSimple
                {:
                    // Consultar en el ámbito actual si está el tipo resgitrado.
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TypeTableIF typeTable = scope.getTypeTable();
                    if(!typeTable.containsType(tSimple.getTipo()))
                    {
                        typeTable.addType(tSimple.getTipo());
                    }
                    List<Token> identificadores = lista.getListaIdentificadores();
                    // Agregar los identificadores a la tabla de símbolos
                    SymbolTableIF symbolTable = scope.getSymbolTable();
                    for(int i = 0; i < identificadores.size(); i++)
                    {
                       if(!symbolTable.containsSymbol(identificadores.get(i).getLexema()))
                       {
                           symbolTable.addSymbol(new SymbolVariable(scope, identificadores.get(i), tSimple.getTipo()));
                       }
                    }
                :} 
           | tipo_registro;

tipo_simple ::= INTEGER:id PUNTOYCOMA declaraciones 
                {: 
                    TypeSimple tipoSimple = new TypeSimple(scopeManager.getCurrentScope(), id.getLexema());
                    RESULT = new TipoSimple(tipoSimple); 
                :}
              | IDENTIFICADOR PUNTOYCOMA declaraciones 
              | BOOLEAN PUNTOYCOMA declaraciones;

lista_identificadores ::= IDENTIFICADOR:id COMA lista_identificadores:lista
                            {:
                                // necesito ámbito, tipo y el token identifocador (me falta el tipo!)
                                if(lista.contiene(id))
                                    semanticErrorManager.semanticFatalError("El identificador ya está declarado en el ámbito actual.");
                                lista.addIdentificador(id);
                            :} 
                        | IDENTIFICADOR:id
                            {:
                                ListaIdentificadores resultado = new ListaIdentificadores();
                                resultado.addIdentificador(id);
                                RESULT = resultado;
                            :};

tipo_registro ::= TYPE IDENTIFICADOR IS RECORD dec_tipo END RECORD PUNTOYCOMA declaraciones ;

dec_subprograma ::= funcion declaraciones 
                  | procedimiento declaraciones;

funcion ::= FUNCTION IDENTIFICADOR ABRE_PARENTESIS parametros_formales CIERRA_PARENTESIS RETURN tipo_retorno IS declaraciones_subprograma BEGIN lista_sentencias END IDENTIFICADOR PUNTOYCOMA;

parametros_formales ::= parametro_formal PUNTOYCOMA parametros_formales 
                      | parametro_formal 
                      | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de parametros formales."); :};
                        
                       
parametro_formal ::= lista_identificadores DECLARACION INTEGER 
                   | lista_identificadores DECLARACION BOOLEAN 
                   |;
                        

tipo_retorno ::= INTEGER 
               | BOOLEAN 
               | error {: syntaxErrorManager.syntaxDebug ("Error en tipo de retorno."); :};

declaraciones_subprograma ::= dec_const_simbolica 
                            | dec_tipo 
                            | dec_subprograma 
                            |;

procedimiento ::= PROCEDURE IDENTIFICADOR ABRE_PARENTESIS parametros_formales CIERRA_PARENTESIS IS declaraciones_subprograma BEGIN lista_sentencias END IDENTIFICADOR PUNTOYCOMA;

lista_sentencias ::= sentencia PUNTOYCOMA lista_sentencias 
                   | sentencia expresion PUNTOYCOMA lista_sentencias 
                   | ;

expresion ::= expresion_aritmetica:expa {: Expresion exp = new Expresion(expa); RESULT = exp; :}
            | expresion_logica 
            | elemento 
            | ABRE_PARENTESIS expresion CIERRA_PARENTESIS 
            | error PUNTOYCOMA {: syntaxErrorManager.syntaxDebug ("Error en expresion."); :};

expresion_aritmetica ::= expresion:e1 PLUS expresion:e2
        {:
            ExpresionAritmetica exp = new ExpresionAritmetica();
            
            if(!e1.getTipoInstruccion().equals(e2.getTipoInstruccion()))
            {
                semanticErrorManager.semanticFatalError("Los tipos no coinciden");
            }
            
            RESULT = exp;
        :};

expresion_logica ::= expresion IGUAL expresion 
                   | expresion OR expresion 
                   | expresion MAYORQUE expresion;

acceso_registro ::= IDENTIFICADOR PUNTO acceso_registro 
                  | IDENTIFICADOR PUNTO IDENTIFICADOR;

llamada_subprograma ::= IDENTIFICADOR ABRE_PARENTESIS parametros_actuales CIERRA_PARENTESIS;

parametros_actuales ::= expresion COMA parametros_actuales 
                      | expresion 
                      |;

elemento ::= IDENTIFICADOR resto 
           | acceso_registro 
           | TRUE 
           | FALSE 
           | CONSTANTE_NUMERICA:id
                {:
                    Expresion exp = new Expresion(new TypeSimple(scopeManager.getCurrentScope(), "ENTERO"));

                    Value resultado=new Value(Integer.parseInt(id.getLexema()));
                    exp.setResultado(resultado);
                    RESULT=exp;
                :};

resto ::= ABRE_PARENTESIS parametros_actuales CIERRA_PARENTESIS 
        | ;

sentencia ::= sentencia_asignacion 
            | sentencia_if 
            | sentencia_for 
            | llamada_subprograma 
            | sentencia_put_line 
            | RETURN expresion 
            | error {: syntaxErrorManager.syntaxDebug ("Error en sentencia."); :};

sentencia_asignacion ::= IDENTIFICADOR ASIGNACION expresion 
                       | acceso_registro ASIGNACION expresion;

sentencia_if ::= IF expresion THEN lista_sentencias END IF 
               | IF expresion THEN lista_sentencias ELSE lista_sentencias END IF;

sentencia_for ::= FOR expresion IN expresion PUNTOPUNTO expresion LOOP lista_sentencias END LOOP;

sentencia_put_line ::= PUT_LINE ABRE_PARENTESIS parametro CIERRA_PARENTESIS;

parametro ::= expresion 
            | CONSTANTE_CADENA;
