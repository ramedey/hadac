package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
		Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales (Ejemplo)

terminal Token ABRE_PARENTESIS;
terminal Token ASIGNACION;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CIERRA_PARENTESIS;
terminal Token COMA;
terminal Token CONSTANT;
terminal Token CONSTANTE_CADENA;
terminal Token CONSTANTE_NUMERICA;
terminal Token DECLARACION;
terminal Token PUNTOPUNTO;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IDENTIFICADOR;
terminal Token IGUAL;
terminal Token INTEGER;
terminal Token IN;
terminal Token IF;
terminal Token IS;
terminal Token LOOP;
terminal Token MAYORQUE;
terminal Token OR;
terminal Token PLUS;
terminal Token PROCEDURE;
terminal Token PUNTO;
terminal Token PUNTOYCOMA;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
// ...


// Declaración de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
non terminal            declaraciones, lista_sentencias;
non terminal            dec_const_simbolica, dec_tipo, dec_subprograma, lista_campos;
non terminal            lista_identificadores;
non terminal            tipo_simple, tipo_registro;
non terminal            tipo_retorno, cuerpo_funcion, sentencia_return;
non terminal            funcion, procedimiento, parametros_formales, parametro_formal, declaraciones_subprograma;
non terminal            expresion, expresion_aritmetica, expresion_logica, acceso_registro, llamada_subprograma, parametros_actuales;
non terminal            sentencia, sentencia_asignacion, sentencia_if, sentencia_for, parametro;
non terminal            sentencia_put_line, elemento, elemento_aritmetico, elemento_logico, resto;
// ...


// Declaración de relaciones de precedencia
precedence left     PUNTO, ABRE_PARENTESIS, CIERRA_PARENTESIS, PLUS, MAYORQUE, IGUAL, OR;
// ...

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		// Para la entrega de febrero pueden comentarse las dos sentencias siguientes:
  		// List intermediateCode = ax.getIntermediateCode ();
  		// finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest en la entrega de Febrero. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega de Junio deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= PROCEDURE IDENTIFICADOR ABRE_PARENTESIS CIERRA_PARENTESIS IS declaraciones BEGIN lista_sentencias END IDENTIFICADOR PUNTOYCOMA;

declaraciones ::= dec_const_simbolica | dec_tipo | dec_subprograma | ;

dec_const_simbolica ::= lista_identificadores DECLARACION CONSTANT ASIGNACION CONSTANTE_NUMERICA PUNTOYCOMA declaraciones |
                        lista_identificadores DECLARACION CONSTANT ASIGNACION TRUE PUNTOYCOMA declaraciones |
                        lista_identificadores DECLARACION CONSTANT ASIGNACION FALSE PUNTOYCOMA declaraciones;

dec_tipo ::= lista_identificadores DECLARACION tipo_simple | tipo_registro ;

tipo_simple ::= INTEGER PUNTOYCOMA declaraciones | 
                IDENTIFICADOR PUNTOYCOMA declaraciones | 
                BOOLEAN PUNTOYCOMA declaraciones;

lista_identificadores ::= IDENTIFICADOR COMA lista_identificadores | IDENTIFICADOR;

tipo_registro ::= TYPE IDENTIFICADOR IS RECORD dec_tipo END RECORD PUNTOYCOMA declaraciones ;

 
lista_campos ::= tipo_simple | IDENTIFICADOR PUNTOYCOMA | tipo_registro;

dec_subprograma ::=  funcion declaraciones | procedimiento declaraciones;

funcion ::= FUNCTION IDENTIFICADOR ABRE_PARENTESIS parametros_formales CIERRA_PARENTESIS RETURN tipo_retorno IS declaraciones_subprograma BEGIN cuerpo_funcion END IDENTIFICADOR PUNTOYCOMA;

parametros_formales ::= parametro_formal PUNTOYCOMA parametros_formales |
                        parametro_formal;
                        
                       
parametro_formal ::= lista_identificadores DECLARACION INTEGER |
                        lista_identificadores DECLARACION BOOLEAN | ;
                        

tipo_retorno ::= INTEGER | BOOLEAN;

declaraciones_subprograma ::= dec_const_simbolica | dec_tipo | dec_subprograma |;

cuerpo_funcion ::= lista_sentencias RETURN expresion PUNTOYCOMA lista_sentencias ;

procedimiento ::= PROCEDURE IDENTIFICADOR ABRE_PARENTESIS parametros_formales CIERRA_PARENTESIS IS declaraciones_subprograma BEGIN lista_sentencias END IDENTIFICADOR PUNTOYCOMA;

lista_sentencias ::= sentencia PUNTOYCOMA lista_sentencias | sentencia expresion PUNTOYCOMA lista_sentencias | ;

expresion ::= expresion_aritmetica | expresion_logica | elemento | ABRE_PARENTESIS expresion CIERRA_PARENTESIS;

expresion_aritmetica ::= expresion PLUS expresion;

expresion_logica ::= expresion IGUAL expresion | expresion OR expresion | expresion MAYORQUE expresion;

acceso_registro ::= IDENTIFICADOR PUNTO acceso_registro | IDENTIFICADOR PUNTO IDENTIFICADOR;

llamada_subprograma ::= IDENTIFICADOR ABRE_PARENTESIS parametros_actuales CIERRA_PARENTESIS;

parametros_actuales ::= elemento COMA parametros_actuales | 
                        elemento;

elemento ::= IDENTIFICADOR resto | elemento_aritmetico | acceso_registro | elemento_logico;

resto ::= ABRE_PARENTESIS parametros_actuales CIERRA_PARENTESIS | ;

elemento_logico ::= TRUE | FALSE ;
               
elemento_aritmetico ::= CONSTANTE_NUMERICA;

sentencia ::= sentencia_asignacion | sentencia_if | sentencia_for | llamada_subprograma | sentencia_put_line;

sentencia_asignacion ::= IDENTIFICADOR ASIGNACION expresion | acceso_registro ASIGNACION expresion;

sentencia_if ::= IF expresion THEN lista_sentencias END IF | IF expresion THEN lista_sentencias ELSE lista_sentencias END IF;

sentencia_for ::= FOR expresion IN expresion PUNTOPUNTO expresion LOOP lista_sentencias END LOOP;

sentencia_put_line ::= PUT_LINE ABRE_PARENTESIS parametro CIERRA_PARENTESIS;

parametro ::= expresion | CONSTANTE_CADENA;
