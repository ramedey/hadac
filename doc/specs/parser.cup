package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.semantic.util.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
		Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales (Ejemplo)

terminal Token ABRE_PARENTESIS;
terminal Token ASIGNACION;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CIERRA_PARENTESIS;
terminal Token COMA;
terminal Token CONSTANT;
terminal Token CONSTANTE_CADENA;
terminal Token CONSTANTE_NUMERICA;
terminal Token DECLARACION;
terminal Token PUNTOPUNTO;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IDENTIFICADOR;
terminal Token IGUAL;
terminal Token INTEGER;
terminal Token IN;
terminal Token IF;
terminal Token IS;
terminal Token LOOP;
terminal Token MAYORQUE;
terminal Token OR;
terminal Token PLUS;
terminal Token PROCEDURE;
terminal Token PUNTO;
terminal Token PUNTOYCOMA;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
// ...


// Declaración de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
non terminal            declaraciones;
non terminal            dec_const_simbolica, dec_tipo, dec_subprograma;
non terminal ListaIdentificadores lista_identificadores;
non terminal TipoSimple tipo_simple, tipo_retorno;
non terminal            tipo_registro;
non terminal Expresion  expresion, expresion_logica, elemento;
non terminal ExpresionAritmetica expresion_aritmetica;
non terminal ParametrosFormales parametros_formales;
non terminal ParametroFormal parametro_formal;
non terminal            funcion, procedimiento, declaraciones_subprograma;
non terminal            acceso_registro, llamada_subprograma, parametros_actuales;
non terminal ListaSentencias lista_sentencias;
non terminal Sentencia sentencia;
non terminal            sentencia_asignacion, sentencia_if, sentencia_for, parametro;
non terminal            sentencia_put_line, resto;
// ...


// Declaración de relaciones de precedencia
precedence left     OR;
precedence left     IGUAL;
precedence left     MAYORQUE;
precedence left     PLUS;
precedence left     PUNTO, ABRE_PARENTESIS, CIERRA_PARENTESIS;
// ...

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Comenzando analisis..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		// Para la entrega de febrero pueden comentarse las dos sentencias siguientes:
  		 List intermediateCode = ax.getIntermediateCode ();
  		 finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest en la entrega de Febrero. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega de Junio deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Proceso de analisis terminado.");
   :};


axiom ::= PROCEDURE IDENTIFICADOR:id ABRE_PARENTESIS CIERRA_PARENTESIS IS declaraciones BEGIN lista_sentencias END IDENTIFICADOR PUNTOYCOMA
        {:
            //Crear el ámbito global del programa asociado al nombre del procedimiento.
            String name = id.getLexema();
            scopeManager.openScope(name);
        :}
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de procedimiento principal."); :};

declaraciones ::= dec_const_simbolica 
                | dec_tipo 
                | dec_subprograma  
                | error declaraciones{: syntaxErrorManager.syntaxDebug ("Error en declaracion."); :}  
                |;

dec_const_simbolica ::= lista_identificadores:lista DECLARACION CONSTANT ASIGNACION CONSTANTE_NUMERICA:numero PUNTOYCOMA declaraciones
                        {:
                            // Ámbito actual
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            // Al ser una constante numérica, su tipo es entero
                            TypeIF tipo = new TypeSimpleInteger(scopeManager.getCurrentScope());
                            
                            // Añadir el tipo a la tabla de tipos
                            TypeTableIF typeTable = scope.getTypeTable();
                            if(!typeTable.containsType(tipo))
                            {
                                typeTable.addType(tipo);
                            }
                            
                            // Añadir los identificadores a la tabla de símbolos
                            List<Token> identificadores = lista.getListaIdentificadores();
                            SymbolTableIF symbolTable = scope.getSymbolTable();
                            for(int i = 0; i < identificadores.size(); i++)
                            {
                                if(!symbolTable.containsSymbol(identificadores.get(i).getLexema()))
                                {
                                    symbolTable.addSymbol(new SymbolIntegerConstant(scope, 
                                                                identificadores.get(i).getLexema(), 
                                                                tipo,
                                                                Integer.parseInt(numero.getLexema())));
                                }
                            }
                    
                        :} 
                      | lista_identificadores:lista DECLARACION CONSTANT ASIGNACION TRUE:constante PUNTOYCOMA declaraciones
                        {:
                             // Ámbito actual
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            // Al ser una constante booleana, su tipo es booleano
                            TypeIF tipo = new TypeSimpleBoolean(scopeManager.getCurrentScope());
                            
                            try{
                                Util.agregarConstanteBooleanaATablasSimbolosYTipos(scope, lista.getListaIdentificadores(), tipo, constante);
                            }catch(Exception ex)
                            {
                                semanticErrorManager.semanticFatalError(ex.getMessage());
                            }
                                                        
                        :}
                      | lista_identificadores:lista DECLARACION CONSTANT ASIGNACION FALSE:constante PUNTOYCOMA declaraciones
                        {:
                             // Ámbito actual
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            // Al ser una constante booleana, su tipo es booleano
                            TypeIF tipo = new TypeSimpleBoolean(scopeManager.getCurrentScope());
                            
                            try{
                                Util.agregarConstanteBooleanaATablasSimbolosYTipos(scope, lista.getListaIdentificadores(), tipo, constante);
                            }catch(Exception ex)
                            {
                                semanticErrorManager.semanticFatalError(ex.getMessage());
                            }
                        :};

dec_tipo ::= lista_identificadores:lista DECLARACION tipo_simple:tSimple
                {:
                    // Consultar en el ámbito actual si está el tipo resgitrado.
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TypeTableIF typeTable = scope.getTypeTable();
                    if(!typeTable.containsType(tSimple.getTipo()))
                    {
                        typeTable.addType(tSimple.getTipo());
                    }
                    List<Token> identificadores = lista.getListaIdentificadores();
                    // Agregar los identificadores a la tabla de símbolos
                    SymbolTableIF symbolTable = scope.getSymbolTable();
                    for(int i = 0; i < identificadores.size(); i++)
                    {
                       if(!symbolTable.containsSymbol(identificadores.get(i).getLexema()))
                       {
                           symbolTable.addSymbol(new SymbolVariable(scope, identificadores.get(i), tSimple.getTipo()));
                       }
                    }
                :} 
           | tipo_registro;

tipo_simple ::= INTEGER:id PUNTOYCOMA declaraciones 
                {: 
                    TypeSimpleInteger tipoSimpleInteger = new TypeSimpleInteger(scopeManager.getCurrentScope());
                    RESULT = new TipoSimple(tipoSimpleInteger); 
                :}
              | IDENTIFICADOR:id PUNTOYCOMA declaraciones
                {:
                    //Si no es ni entero ni booleano, solo puede ser un tipo registro.
                    // Comprobar si el tipo está registrado en el ámbito actual
                    ScopeIF scope = scopeManager.getCurrentScope();
                    Util.comprobarExisteSimboloEnAmbito(id.getLexema(), scope);
                    //AQUI TENGO UN PROBLEMA CON LA GRAMÁTICA!
                    //RESULT = scope.getSymbolTable().getSymbol(id.getLexema());
                :} 
              | BOOLEAN:id PUNTOYCOMA declaraciones                
                {: 
                    TypeSimpleBoolean tipoSimpleBoolean = new TypeSimpleBoolean(scopeManager.getCurrentScope());
                    RESULT = new TipoSimple(tipoSimpleBoolean);
                :};

lista_identificadores ::= IDENTIFICADOR:id COMA lista_identificadores:lista
                            {:
                                // necesito ámbito, tipo y el token identifocador (me falta el tipo!)
                                if(lista.contiene(id))
                                    semanticErrorManager.semanticFatalError("El identificador ya está declarado en el ámbito actual.");
                                lista.addIdentificador(id);
                            :} 
                        | IDENTIFICADOR:id
                            {:
                                ListaIdentificadores resultado = new ListaIdentificadores();
                                resultado.addIdentificador(id);
                                RESULT = resultado;
                            :};

tipo_registro ::= TYPE IDENTIFICADOR:id IS RECORD:tipo dec_tipo END RECORD PUNTOYCOMA declaraciones 
                    {:
                        // Consultar en el ámbito actual si está el tipo resgitrado.
                        ScopeIF scope = scopeManager.getCurrentScope();
                        TypeTableIF typeTable = scope.getTypeTable();
                        TypeRecord tipoRecord = new TypeRecord(scope, id.getLexema());
                        if(!typeTable.containsType(tipo.getLexema()))
                        {
                            typeTable.addType(tipoRecord);
                        }
                        SymbolTableIF symbolTable = scope.getSymbolTable();
                        if(!symbolTable.containsSymbol(id.getLexema()))
                        {
                           symbolTable.addSymbol(new SymbolVariable(scope, id, tipoRecord));
                        }
                    :};

dec_subprograma ::= funcion declaraciones 
                  | procedimiento declaraciones;

funcion ::= FUNCTION IDENTIFICADOR:id ABRE_PARENTESIS parametros_formales:parametros CIERRA_PARENTESIS RETURN tipo_retorno:tipoRetorno IS declaraciones_subprograma BEGIN lista_sentencias:listaSentencias END IDENTIFICADOR PUNTOYCOMA
                {:
                    // registrar la funcion en el ambito actual
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TypeFunction function = new TypeFunction(scope, id.getLexema());
                    function.setTipoRetorno(tipoRetorno.getTipo());
                    Util.actualizarTablasSimbolosYTipos(scope, id, function);
                    ScopeIF newScope = scopeManager.openScope(id.getLexema());
                    function.setParametros(parametros.getParametros());
                    
                    //Registrar las declaraciones en el ambito actual
                    
                    //Comprobar que en el cuerpo existe la sentencia "return"
                    // y que su tipo coincide con el tipo de retorno declarado
                    // en la cabecera de la función.
                    if(listaSentencias.tieneSentenciaReturn())
                    {
                        SentenciaReturn sent = listaSentencias.getSentenciaReturn();
                        
                        if(sent.getTipoDevolucion() != function.getTipoRetorno())
                        {
                            semanticErrorManager.semanticFatalError("El tipo de retorno no coincide con el tipo de la sentencia Return");
                        }
                    }else{
                        semanticErrorManager.semanticFatalError("La función declarada no tiene sentencia Return");
                    }
                :};


parametros_formales ::= parametro_formal:parametro PUNTOYCOMA parametros_formales:parametros
                        {:
                            parametros.addParametro(parametro);
                        :}
                      | parametro_formal:parametro 
                        {:
                            ParametrosFormales parametros = new ParametrosFormales();
                            parametros.addParametro(parametro);
                            RESULT = parametros;
                        :}
                      | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de parametros formales."); :};
                        
                       
parametro_formal ::= lista_identificadores:lista DECLARACION INTEGER 
                        {:
                            RESULT = new ParametroFormal(lista, new TypeSimpleInteger(scopeManager.getCurrentScope()));                            
                        :}
                   | lista_identificadores:lista DECLARACION BOOLEAN 
                        {:
                            RESULT = new ParametroFormal(lista, new TypeSimpleBoolean(scopeManager.getCurrentScope()));                            
                        :}
                   |;
                        

tipo_retorno ::= INTEGER {: RESULT = new TipoSimple(new TypeSimpleInteger(scopeManager.getCurrentScope()));:}
               | BOOLEAN {: RESULT = new TipoSimple(new TypeSimpleBoolean(scopeManager.getCurrentScope()));:}
               | error {: syntaxErrorManager.syntaxDebug ("Error en tipo de retorno."); :};

declaraciones_subprograma ::= dec_const_simbolica 
                            | dec_tipo 
                            | dec_subprograma 
                            |;

procedimiento ::= PROCEDURE IDENTIFICADOR:id ABRE_PARENTESIS parametros_formales:parametros CIERRA_PARENTESIS IS declaraciones_subprograma BEGIN lista_sentencias END IDENTIFICADOR PUNTOYCOMA
                    {:
                         // registrar la funcion en el ambito actual
                        ScopeIF scope = scopeManager.getCurrentScope();
                        TypeProcedure procedure = new TypeProcedure(scope, id.getLexema());
                        Util.actualizarTablasSimbolosYTipos(scope, id, procedure);
                        ScopeIF newScope = scopeManager.openScope(id.getLexema());
                        procedure.setParametros(parametros.getParametros());
                    
                        //Registrar las declaraciones en el ambito actual
                    :};

lista_sentencias ::= sentencia PUNTOYCOMA lista_sentencias 
                   | sentencia expresion PUNTOYCOMA lista_sentencias 
                   | ;

expresion ::= expresion_aritmetica:expa {: RESULT = expa; :}
            | expresion_logica 
            | elemento 
            | ABRE_PARENTESIS expresion CIERRA_PARENTESIS 
            | error PUNTOYCOMA {: syntaxErrorManager.syntaxDebug ("Error en expresion."); :};

expresion_aritmetica ::= expresion:e1 PLUS expresion:e2
        {:        
            try{
                RESULT = new ExpresionAritmetica(e1, e2);
            }catch(Exception ex){
                semanticErrorManager.semanticFatalError(ex.getMessage());
            }
        :};

expresion_logica ::= expresion:e1 IGUAL expresion:e2 
                     {:
                         try{
                                RESULT = new ExpresionLogica(e1, e2, ExpresionLogica.Operation.Eq);
                         }catch(Exception ex){
                                semanticErrorManager.semanticFatalError(ex.getMessage());
                         }
                     :}
                   | expresion:e1 OR expresion:e2
                     {:
                         try{
                                RESULT = new ExpresionLogica(e1, e2, ExpresionLogica.Operation.Or);
                         }catch(Exception ex){
                                semanticErrorManager.semanticFatalError(ex.getMessage());
                         }
                     :} 
                   | expresion:e1 MAYORQUE expresion:e2
                     {:
                         try{
                                RESULT = new ExpresionLogica(e1, e2, ExpresionLogica.Operation.Gt);
                         }catch(Exception ex){
                                semanticErrorManager.semanticFatalError(ex.getMessage());
                         }
                     :};

acceso_registro ::= IDENTIFICADOR:id PUNTO acceso_registro 
                    {:
                        // Comprobar que existe el identificador en el ambito actual
                        ScopeIF scope = scopeManager.getCurrentScope();
                        Util.comprobarExisteSimboloEnAmbito(id.getLexema(), scope);
                    :}
                  | IDENTIFICADOR:id1 PUNTO IDENTIFICADOR:id2
                    {:
                        // Comprobar que existe el identificador en el ambito actual
                        ScopeIF scope = scopeManager.getCurrentScope();
                        Util.comprobarExisteSimboloEnAmbito(id1.getLexema(), scope);
                    :};

llamada_subprograma ::= IDENTIFICADOR:id ABRE_PARENTESIS parametros_actuales:parametros CIERRA_PARENTESIS
                        {:
                            ScopeIF scope = scopeManager.getCurrentScope();
                            SymbolTableIF symbolTable = scope.getSymbolTable ();
                            TypeTableIF typeTable = scope.getTypeTable ();
                            if (!(symbolTable.containsSymbol(id.getLexema())) && !(typeTable.containsType(id.getLexema()))) { 
                                //comprobar los parametros si coinciden en numero y tipo
                                
                            }
                        :};

parametros_actuales ::= expresion COMA parametros_actuales 
                      | expresion 
                      |;

elemento ::= IDENTIFICADOR resto 
           | acceso_registro 
           | TRUE 
           | FALSE 
           | CONSTANTE_NUMERICA:id
                {:
                    ExpresionAritmetica expa = new ExpresionAritmetica(Integer.parseInt(id.getLexema()), scopeManager.getCurrentScope());
                    RESULT=expa;
                :};

resto ::= ABRE_PARENTESIS parametros_actuales CIERRA_PARENTESIS 
        | ;

sentencia ::= sentencia_asignacion 
            | sentencia_if 
            | sentencia_for 
            | llamada_subprograma 
            | sentencia_put_line 
            | RETURN expresion 
            | error {: syntaxErrorManager.syntaxDebug ("Error en sentencia."); :};

sentencia_asignacion ::= IDENTIFICADOR ASIGNACION expresion 
                       | acceso_registro ASIGNACION expresion;

sentencia_if ::= IF expresion THEN lista_sentencias END IF 
               | IF expresion THEN lista_sentencias ELSE lista_sentencias END IF;

sentencia_for ::= FOR expresion IN expresion PUNTOPUNTO expresion LOOP lista_sentencias END LOOP;

sentencia_put_line ::= PUT_LINE ABRE_PARENTESIS parametro CIERRA_PARENTESIS;

parametro ::= expresion 
            | CONSTANTE_CADENA;
