package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.semantic.util.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();
	
	public void aserto(boolean esCierto, String mensajeError){
	
	   if(!esCierto)
	   {
	       semanticErrorManager.semanticFatalError(mensajeError);
	   }
	}
	
	   public void aserto(boolean esCierto, String mensajeError, int linea){
    
       if(!esCierto)
       {
           semanticErrorManager.semanticFatalError(mensajeError + ". Linea " + linea);
       }
    }

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
		Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales (Ejemplo)

terminal Token ABRE_PARENTESIS;
terminal Token ASIGNACION;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CIERRA_PARENTESIS;
terminal Token COMA;
terminal Token CONSTANT;
terminal Token CONSTANTE_CADENA;
terminal Token CONSTANTE_NUMERICA;
terminal Token DECLARACION;
terminal Token PUNTOPUNTO;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IDENTIFICADOR;
terminal Token IGUAL;
terminal Token INTEGER;
terminal Token IN;
terminal Token IF;
terminal Token IS;
terminal Token LOOP;
terminal Token MAYORQUE;
terminal Token OR;
terminal Token PLUS;
terminal Token PROCEDURE;
terminal Token PUNTO;
terminal Token PUNTOYCOMA;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
// ...


// Declaración de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
non terminal Declaraciones  declaraciones, dec_const_simbolica, dec_tipo_registro, declaraciones_subprograma;
non terminal DecVariables dec_variables, dec_campos_registro;
non terminal ListaIdentificadores lista_identificadores;
non terminal TypeSimple tipo_retorno, tipo_parametro;
non terminal Expresion  expresion, expresion_logica;
non terminal Elemento   elemento;
non terminal AccesoRegistro acceso_registro;
non terminal ExpresionAritmetica expresion_aritmetica;
non terminal ParametrosFormales parametros_formales;
non terminal Declaraciones procedimiento;
non terminal DecSubprograma dec_subprograma, funcion;
non terminal LlamadaProcedimiento llamada_subprograma;
non terminal ParametrosActuales parametros_actuales;
non terminal ListaSentencias lista_sentencias;
non terminal Sentencia sentencia, sentencia_put_line, sentencia_asignacion, sentencia_if, sentencia_for;
// ...


// Declaración de relaciones de precedencia
precedence left     OR;
precedence left     IGUAL;
precedence left     MAYORQUE;
precedence left     PLUS;
precedence left     PUNTO, ABRE_PARENTESIS, CIERRA_PARENTESIS;
// ...

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Comenzando analisis..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		// Para la entrega de febrero pueden comentarse las dos sentencias siguientes:
  		
  		 MemoryManager.assignAddresses();
  		 
  		 IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
  		 //cb.addQuadruple ("DATA", gAddress);
  		 cb.addQuadruple (InstructionSetArchitecture.INICIO, MemoryManager.getgAddress(), ax.getMainLabel());
  		 
  		 List intermediateCode = ax.getIntermediateCode ();
		 
  		 cb.addQuadruples (intermediateCode);
         cb.addQuadruple (InstructionSetArchitecture.FINAL);
  		 
  		 finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		 finalCodeFactory.create (cb.create());
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest en la entrega de Febrero. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega de Junio deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Proceso de analisis terminado.");
   :};


axiom ::= PROCEDURE IDENTIFICADOR:id 
            {:
                //Crear el ámbito global del programa asociado al nombre del procedimiento.
                String name = id.getLexema();
                scopeManager.openScope(name);
                syntaxErrorManager.syntaxInfo("Ambito global " + name);
            :}
        ABRE_PARENTESIS CIERRA_PARENTESIS IS declaraciones:decl BEGIN lista_sentencias:lista
        {:         
            syntaxErrorManager.syntaxInfo("Termina cuerpo programa");
            Axiom ax = new Axiom();
            syntaxErrorManager.syntaxInfo("Sentencias: " + lista);
            
            LabelFactoryIF lF = new LabelFactory ();
            LabelIF l1 = lF.create (id.getLexema());
            ax.setMainLabel(l1);
            if(decl != null)
            {
                ax.getIntermediateCode().addAll(decl.getIntermediateCode());
            }
            IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
            cb.addQuadruple (InstructionSetArchitecture.LABEL, l1);
            ax.getIntermediateCode().addAll(cb.create());
            if(lista != null)
            {
                ax.getIntermediateCode().addAll(lista.getIntermediateCode());
            }

            
            RESULT = ax;
        :}
        END IDENTIFICADOR PUNTOYCOMA
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de procedimiento principal."); :};

declaraciones ::= dec_const_simbolica:dConst declaraciones:decl {: 
                semanticErrorManager.semanticInfo("Declaracion de constantes " + dConst);
                RESULT =  decl.addDeclaracion(dConst);:}
                | dec_variables:dVar declaraciones:decl 
                {: 
                    semanticErrorManager.semanticInfo("Declaracion de variables" + dVar);
                    RESULT =  decl.addDeclaracion(dVar);:}
                | dec_tipo_registro declaraciones:decl {: 
                    //Las declaraciones de tipo registro no producen CI 
                    RESULT =  decl;:}
                | dec_subprograma:dSub declaraciones:decl {: RESULT =  decl.addDeclaracion(dSub);:}
                | error declaraciones {: syntaxErrorManager.syntaxDebug ("Error en declaracion."); :}  
                | {: syntaxErrorManager.syntaxInfo("Fin declaraciones"); RESULT = new Declaraciones(); :};

dec_const_simbolica ::= lista_identificadores:lista DECLARACION CONSTANT ASIGNACION CONSTANTE_NUMERICA:numero PUNTOYCOMA
                        {:
                            semanticErrorManager.semanticInfo("Declaracion de constantes numericas en linea " + numero.getLine());
                            // Ámbito actual
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            // Al ser una constante numérica, su tipo es entero
                            TypeIF tipo = new TypeSimpleInteger(scopeManager.getCurrentScope());
                            
                            // Añadir el tipo a la tabla de tipos
                            TypeTableIF typeTable = scope.getTypeTable();
                            if(!typeTable.containsType(tipo))
                            {
                                typeTable.addType(tipo);
                            }
                            
                            // Añadir los identificadores a la tabla de símbolos
                            List<Token> identificadores = lista.getListaIdentificadores();
                            SymbolTableIF symbolTable = scope.getSymbolTable();
                            for(int i = 0; i < identificadores.size(); i++)
                            {
                                if(!symbolTable.containsSymbol(identificadores.get(i).getLexema()))
                                {
                                    symbolTable.addSymbol(new SymbolIntegerConstant(scope, 
                                                                identificadores.get(i).getLexema(), 
                                                                tipo,
                                                                Integer.parseInt(numero.getLexema())));
                                }
                            }
                             Declaraciones dec = new Declaraciones();
                             RESULT = dec;
                        :} 
                      | lista_identificadores:lista DECLARACION CONSTANT ASIGNACION TRUE:constante PUNTOYCOMA 
                        {:
                        semanticErrorManager.semanticInfo("Declaracion de constantes con valor true en linea " + constante.getLine());
                            
                             // Ámbito actual
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            // Al ser una constante booleana, su tipo es booleano
                            TypeIF tipo = new TypeSimpleBoolean(scopeManager.getCurrentScope());
                            
                            Util.agregarConstanteBooleanaATablasSimbolosYTipos(scope, lista.getListaIdentificadores(), tipo, constante);
                            
                            Declaraciones dec = new Declaraciones();
                             RESULT = dec;
                        :}
                      | lista_identificadores:lista DECLARACION CONSTANT ASIGNACION FALSE:constante PUNTOYCOMA 
                        {:
                            semanticErrorManager.semanticInfo("Declaracion de constantes con valor false en linea " + constante.getLine());
                            
                             // Ámbito actual
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            // Al ser una constante booleana, su tipo es booleano
                            TypeIF tipo = new TypeSimpleBoolean(scopeManager.getCurrentScope());
                            
                            Util.agregarConstanteBooleanaATablasSimbolosYTipos(scope, lista.getListaIdentificadores(), tipo, constante);
                            
                            Declaraciones dec = new Declaraciones();
                             RESULT = dec;
                        :};

dec_campos_registro ::= dec_variables:dec dec_campos_registro:dec_reg 
                        {:
                            for(DecVariable decVar : dec.getDeclaraciones())
                            {
                                dec_reg.addDeclaracion(decVar);
                            }
                            RESULT = dec_reg;
                        :}
                        | dec_variables:dec
                        {:
                            RESULT = dec;
                        :};

dec_variables ::= lista_identificadores:lista DECLARACION INTEGER:id PUNTOYCOMA 
                {:
                    syntaxErrorManager.syntaxInfo("Declaracion de variables de tipo entero. Linea " + id.getLine());
                    // comprobar si ya hay una variable con el mismo nombre en el ambito actual
                    // El objeto DecVariable hace la comprobación.
                    //registrar identificadores y devolver objeto Decvariable
                    RESULT = new DecVariables(new DecVariable(lista, new TypeSimpleInteger(scopeManager.getCurrentScope()),
                    scopeManager.getCurrentScope()));
                :} |
             lista_identificadores:lista DECLARACION IDENTIFICADOR:id PUNTOYCOMA 
                {:
                    //registrar identificadores y devolver objeto Decvariable
                    TypeIF tipo = Util.buscarTipoPreviamenteDeclarado(scopeManager, id.getLexema());
                    
                    // El tipo record debe estár declarado y ser visible en el ámbito actual
                    aserto(tipo != null, "El tipo " + id.getLexema() + " no esta declarado o no es visible en este ambito", id.getLine());
                                        
                    RESULT = new DecVariables(new DecVariable(lista, tipo, scopeManager.getCurrentScope()));
                :} |
             lista_identificadores:lista DECLARACION BOOLEAN:id PUNTOYCOMA 
                {:
                    //registrar identificadores y devolver objeto Decvariable
                    RESULT = new DecVariables(new DecVariable(lista, new TypeSimpleBoolean(scopeManager.getCurrentScope()),
                    scopeManager.getCurrentScope()));
                :};

lista_identificadores ::= IDENTIFICADOR:id COMA lista_identificadores:lista
                            {:
                                // necesito ámbito, tipo y el token identifocador (me falta el tipo!)
                                aserto(!lista.contiene(id), "El identificador " + id.getLexema() + " ya está declarado en el ámbito actual. linea " + id.getLine());
                                lista.addIdentificador(id);
                                RESULT = lista;
                            :} 
                        | IDENTIFICADOR:id
                            {:                                
                                ListaIdentificadores resultado = new ListaIdentificadores();
                                resultado.addIdentificador(id);
                                RESULT = resultado;
                                
                            :};

dec_tipo_registro ::= TYPE IDENTIFICADOR:id IS RECORD dec_campos_registro:declaraciones END RECORD PUNTOYCOMA 
                    {:
                        syntaxErrorManager.syntaxInfo("Declaracion de registro " + id.getLexema() + ". Linea " + id.getLine());
                    
                        // Consultar en el ámbito actual si está el tipo resgitrado.
                        ScopeIF scope = scopeManager.getCurrentScope();
                        TypeTableIF typeTable = scope.getTypeTable();
                        TypeRecord tipoRecord = new TypeRecord(scope, id.getLexema(), declaraciones);
                        aserto(!typeTable.containsType(id.getLexema()), "El tipo ya esta declarado. Linea " + id.getLine());
                        semanticErrorManager.semanticInfo("Agrego el tipo " + id.getLexema() + " a la tabla de tipos del ambito " + scope);
                        typeTable.addType(tipoRecord);
                     :};

dec_subprograma ::= funcion:fun {: RESULT = fun;:}
                  | procedimiento:proc {: //RESULT = proc;:};

funcion ::= FUNCTION IDENTIFICADOR:id ABRE_PARENTESIS 
            {:
                    //Abrir ambito de la funcion
                    scopeManager.openScope(id.getLexema());
            :}
            parametros_formales:parametros CIERRA_PARENTESIS RETURN tipo_retorno:tipoRetorno
            {:
                   semanticErrorManager.semanticInfo("Linea " + id.getLine() + ". Declaracion de funcion " + id.getLexema());
                   
                    // registrar la funcion en el ambito actual
                    ScopeIF scope = scopeManager.getCurrentScope().getParentScope();
                    
                    //Actualizar tablas de tipos y simbolos
                    
                    TypeFunction function = new TypeFunction(scope, id.getLexema());
                    
                    function.setTipoRetorno(tipoRetorno);
                    TypeTableIF typeTable = scope.getTypeTable();
                    aserto(!typeTable.containsType(function), "El tipo " + id.getLexema() + " ya existe en el ambito actual.");
                    
                    typeTable.addType(function);
                    semanticErrorManager.semanticInfo("Funcion " + id.getLexema() + ". Linea " + id.getLine() + ". Agregando tipo al ambito " + scope);
                   
            :} 
            IS declaraciones_subprograma:decl BEGIN lista_sentencias:listaSentencias END IDENTIFICADOR PUNTOYCOMA
                {:
                    
                    TypeFunction function = (TypeFunction)scopeManager.searchType(id.getLexema());
                        
                    if(parametros != null)
                    {
                        function.setParametros(parametros.getParametros());
                    }
                    
                    //Comprobar que en el cuerpo existe la sentencia "return"
                    aserto(listaSentencias != null, "La función declarada no tiene sentencia Return");
                    aserto(listaSentencias.tieneSentenciaReturn(), "La funcion declarada no tiene sentencia Return");
                    
                    SentenciaReturn sent = listaSentencias.getSentenciaReturn();
                    aserto(sent != null, "La funcion declarada no tiene sentencia Return");
                    // Comprobar que su tipo coincide con el tipo de retorno declarado
                    // en la cabecera de la función.
                    aserto(sent.getTipoDevolucion().getName().equals(function.getTipoRetorno().getName()), "El tipo de retorno no coincide con el tipo de la sentencia Return: " + 
                    sent.getTipoDevolucion() + " == " + function.getTipoRetorno());
                    
                    //Agrego la sentencia return al tipo para poder propagar la expresion 
                    // de la sentencia de retorno al contexto donde se usa (por ejemplo una
                    // sentencia de asignacion)
                    function.setSentenciaReturn(sent);
                    
                    DecSubprograma fun = new DecSubprograma(id.getLexema(), decl, listaSentencias);
                    fun.generarCodigoIntermedio();
                    
                    scopeManager.closeScope();
                    
                    RESULT = fun;
                   
                :};


parametros_formales ::= lista_identificadores:lista DECLARACION tipo_parametro:tipo PUNTOYCOMA parametros_formales:parametros
                        {:
                        syntaxErrorManager.syntaxInfo("Declaracion de parametros formales");
                            parametros.addParametros(lista, tipo);
                            RESULT = parametros;
                        :}
                      | lista_identificadores:lista DECLARACION tipo_parametro:tipo 
                        {:
                            syntaxErrorManager.syntaxInfo("Declaracion de parametro formal");
                            ParametrosFormales parametros = new ParametrosFormales(lista, tipo);
                            RESULT = parametros;
                            syntaxErrorManager.syntaxInfo("Fin Declaracion de parametro formal");
                        :}
                      | ;
                        
                       
tipo_parametro ::= INTEGER 
                        {:
                            RESULT = new TypeSimpleInteger(scopeManager.getCurrentScope());                            
                        :}
                   | BOOLEAN 
                        {:
                            RESULT = new TypeSimpleBoolean(scopeManager.getCurrentScope());                            
                        :};
                        

tipo_retorno ::= INTEGER {: RESULT = new TypeSimpleInteger(scopeManager.getCurrentScope());:}
               | BOOLEAN {: RESULT = new TypeSimpleBoolean(scopeManager.getCurrentScope());:}
               | error {: syntaxErrorManager.syntaxDebug ("Error en tipo de retorno."); :};

declaraciones_subprograma ::= dec_const_simbolica:dConst declaraciones_subprograma:decs {: RESULT = decs.addDeclaracion(dConst);:}
                            | dec_variables:dVar declaraciones_subprograma:decs {: 
                            semanticErrorManager.semanticInfo("Declaracion de variables en subprograma " + decs);
                            RESULT = decs.addDeclaracion(dVar);:}
                            | dec_subprograma:dSub declaraciones_subprograma:decs {: RESULT = decs.addDeclaracion(dSub);:}
                            | {: RESULT = new Declaraciones();:};

procedimiento ::= PROCEDURE IDENTIFICADOR:id ABRE_PARENTESIS parametros_formales:parametros
                    {:
                        //Abrir ambito de la funcion
                        scopeManager.openScope(id.getLexema());
                        syntaxErrorManager.syntaxInfo("Declaracion de procedimiento " + id.getLexema());
                        
                         // registrar el procedimiento en el ambito actual
                        ScopeIF scope = scopeManager.getCurrentScope().getParentScope();
                        TypeProcedure tipo = new TypeProcedure(scope, id.getLexema(), parametros.getParametros());
                       
                        TypeTableIF typeTable = scope.getTypeTable();
                        aserto(!typeTable.containsType(tipo), "El tipo ya esta registrado en el ambito: " + scope);
                       
                        typeTable.addType(tipo);
                    :}
                    CIERRA_PARENTESIS IS declaraciones_subprograma:decl BEGIN lista_sentencias:lista END IDENTIFICADOR PUNTOYCOMA
                    {:
                                                
                        Declaraciones proc = new Declaraciones(decl);
                        Procedure procedure = new Procedure(id.getLexema(), scopeManager.getCurrentScope());
                        proc.getIntermediateCode().addAll(0, lista.getIntermediateCode());
                        IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getParentScope());
                        cb.addQuadruple(InstructionSetArchitecture.LABEL, procedure.getCodeLabel());
                        proc.getIntermediateCode().addAll(cb.create());
                        //Cierro el ambito del subprograma
                        scopeManager.closeScope();
                        syntaxErrorManager.syntaxInfo("Ambitos: " + scopeManager.getCurrentScope());
                        RESULT = proc;                                           
                        
                    :};

lista_sentencias ::= sentencia:sent PUNTOYCOMA lista_sentencias:lista
                    {: 
                    
                        //syntaxErrorManager.syntaxInfo("Lista de sentenciass. lista es " + lista + ". Sentencia es " + sent); 
                        //Agregar la sentencia a la lista de sentencias
                        
                        if(lista == null){
                            lista = new ListaSentencias();
                        }
                            
                        if(sent != null){
                            lista.agregarSentenciaOExpresion(sent);
                        }
                        lista.generarCodigoIntermedio();
                        RESULT = lista;
                    
                    :}
                   | sentencia:sent expresion:exp PUNTOYCOMA lista_sentencias:lista 
                    {: 
                    
                        //syntaxErrorManager.syntaxInfo("Lista de sentencias. lista es " + lista + ". Sentencia es " + sent); 
                        //Agregar la sentencia a la lista de sentencias
                        if(lista == null){
                            lista = new ListaSentencias();
                        }
                        if(sent != null){
                            lista.agregarSentenciaOExpresion(sent);
                        }
                        if(exp != null){
                            lista.agregarSentenciaOExpresion(exp);
                        }
                        lista.generarCodigoIntermedio();
                        
                        RESULT = lista;
                    
                    :}
                   | ;

expresion ::= expresion_aritmetica:expa {: RESULT = expa; :}
            | expresion_logica:expl {: RESULT = expl; :}
            | elemento:elto {: RESULT = elto; :}             
            | ABRE_PARENTESIS expresion:exp CIERRA_PARENTESIS {: RESULT = exp; :}
            | error PUNTOYCOMA {: syntaxErrorManager.syntaxDebug ("Error en expresion."); :};

expresion_aritmetica ::= expresion:e1 PLUS:plus expresion:e2
        {:        
            //syntaxErrorManager.syntaxInfo("Expresion aritmetica en linea: " + plus.getLine());
            
            ExpresionAritmetica e = new ExpresionAritmetica(e1, e2);
            
            e.generarCodigoIntermedio();
            semanticErrorManager.semanticDebug(e.getIntermediateCode());
            RESULT = e;        
        :};

expresion_logica ::= expresion:e1 IGUAL expresion:e2 
                     {:
                        ExpresionLogica e = new ExpresionLogica(e1, e2, ExpresionLogica.Operation.Eq);
                        e.generarCodigoIntermedio();
                        semanticErrorManager.semanticDebug(e.getIntermediateCode());
                        RESULT = e;
                     :}
                   | expresion:e1 OR expresion:e2
                     {:
                        ExpresionLogica e = new ExpresionLogica(e1, e2, ExpresionLogica.Operation.Or);
                        e.generarCodigoIntermedio();
                        semanticErrorManager.semanticDebug(e.getIntermediateCode());
                        RESULT = e;
                     :} 
                   | expresion:e1 MAYORQUE expresion:e2
                     {:
                        ExpresionLogica e = new ExpresionLogica(e1, e2, ExpresionLogica.Operation.Gt);
                        e.generarCodigoIntermedio();
                        semanticErrorManager.semanticDebug(e.getIntermediateCode());
                        RESULT = e;
                     :};

acceso_registro ::= acceso_registro:acreg PUNTO IDENTIFICADOR:id 
                    {:
                        String nombreCampo = id.getLexema();
                        semanticErrorManager.semanticInfo("Acceso a registro dentro de registro " + nombreCampo);
                        // Comprobar que existe el identificador en el ambito actual
                        ScopeIF scope = scopeManager.getCurrentScope();
                        SymbolVariable variable = (SymbolVariable)Util.comprobarExisteSimboloEnAmbito(nombreCampo, scope);
                        
                        AccesoRegistro accesoRegistro = (AccesoRegistro)acreg;
                        semanticErrorManager.semanticInfo("Acceso a registro dentro de registro " + variable.getType());
                        //El tipo en este caso debe ser TypeRecord
                        aserto(variable.getType() instanceof TypeRecord, "La variable " + variable.getName() + "no no es de tipo registro.", id.getLine());
                                        
                        accesoRegistro.referenciarCampo(nombreCampo);
                        
                        RESULT = accesoRegistro;
                    :}
                  | IDENTIFICADOR:id1 PUNTO IDENTIFICADOR:id2
                    {:
                        // Comprobar que existe el identificador en el ambito actual
                        ScopeIF scope = scopeManager.getCurrentScope();
                        SymbolVariable variable = (SymbolVariable)Util.comprobarExisteSimboloEnAmbito(id1.getLexema(), scope);
                        aserto(variable.getType() != null, "El tipo es nulo " + variable);
                        
                        // Crear objeto SymbolVariableRecord indicando el campo del registro que se esta referenciando.
                        AccesoRegistro acreg = new AccesoRegistro(variable, id2.getLexema());
                        
                        acreg.generarCodigoIntermedio();
                        
                        RESULT = acreg;
                        
                        
                    :};

llamada_subprograma ::= IDENTIFICADOR:id ABRE_PARENTESIS parametros_actuales:parametros CIERRA_PARENTESIS
                        {:
                            String nombreSubprograma = id.getLexema();
                            
                            syntaxErrorManager.syntaxInfo("Llamada al subprograma " + id.getLexema());
                            //Comprobar si elsubprograma es visible desde el ámbito actual
                            semanticErrorManager.semanticDebug("CI parametros: " + parametros.getIntermediateCode());
                            TypeIF tipo = Util.buscarTipoPreviamenteDeclarado(scopeManager, nombreSubprograma);

                            aserto(scopeManager.containsType(nombreSubprograma), "El procedimiento o funcion " + nombreSubprograma + 
                            " no existe. Ambitos " + scopeManager.getOpenScopes());
                            //comprobar los parametros si coinciden en orden, numero y tipo
                            TypeProcedure tipoSubprograma = (TypeProcedure)tipo;                              
                            aserto(tipoSubprograma.validarParametros(parametros.getParametros()), "Los parámetros no coinciden");
                            if(tipoSubprograma instanceof TypeFunction)
                            {
                                LlamadaFuncion funcion = new LlamadaFuncion(tipoSubprograma, parametros);
                                funcion.generarCodigoIntermedio();
                                RESULT = funcion;
                            }else{
                                LlamadaProcedimiento procedimiento = new LlamadaProcedimiento(tipoSubprograma, parametros);
                                procedimiento.generarCodigoIntermedio();
                                RESULT = procedimiento;
                            }
                                                                                             
                        :};

parametros_actuales ::= expresion:exp COMA parametros_actuales:par 
                        {:
                            ParametrosActuales params = new ParametrosActuales(exp, par);
                            params.generarCodigoIntermedio();
                            RESULT = params;
                        :}
                      | expresion:exp
                        {:
                            ParametrosActuales params = new ParametrosActuales(exp);
                            params.generarCodigoIntermedio();
                            RESULT = params;
                        :}
                      |;

elemento ::= acceso_registro:reg 
                {: 
                    semanticErrorManager.semanticDebug("Acceso a registro: " + reg.getCampoReferenciado().getName());
                                                
                    RESULT = reg;
                :}
           | TRUE:id 
                {: 
                    semanticErrorManager.semanticDebug("Elto. Linea: " + id.getLine() +". Valor: " + id.getLexema());
                    boolean verdadero = Util.convertirStringABoolean(id.getLexema());
                    Elemento e = new Elemento(new TypeSimpleBoolean(scopeManager.getCurrentScope()));
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TemporalFactory tF = new TemporalFactory (scope);
                    IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
                    TemporalIF temp = tF.create ();
                    cb.addQuadruple ("MV", temp, new Value(verdadero));
                    e.setTemporal(temp);
                    e.setIntermediateCode(cb.create());
                    RESULT = e; 
                :}
           | FALSE:id
                {: 
                    semanticErrorManager.semanticDebug("Elto. Linea: " + id.getLine() +". Valor: " + id.getLexema());
                    boolean falso = Util.convertirStringABoolean(id.getLexema());
                    Elemento e = new Elemento(new TypeSimpleBoolean(scopeManager.getCurrentScope())); 
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TemporalFactory tF = new TemporalFactory (scope);
                    IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
                    TemporalIF temp = tF.create ();
                    cb.addQuadruple ("MV", temp, new Value(falso));
                    e.setTemporal(temp);
                    e.setIntermediateCode(cb.create());
                    RESULT = e;
                :}
           | CONSTANTE_NUMERICA:id
                {:
                    semanticErrorManager.semanticDebug("Cte numerica en linea " + id.getLine() +". Valor: " + id.getLexema());
                    int numero = Integer.parseInt(id.getLexema());
                    Elemento e = new Elemento(new TypeSimpleInteger(scopeManager.getCurrentScope()));
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TemporalFactory tF = new TemporalFactory (scope);
                    IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
                    TemporalIF temp = tF.create ();
                    cb.addQuadruple ("MV", temp, new Value(numero));
                    e.setTemporal(temp);
                    e.setIntermediateCode(cb.create());
                    RESULT = e;
                :}
           | llamada_subprograma:llamada 
            {: 
                syntaxErrorManager.syntaxInfo("Llamada subprograma " + (llamada instanceof LlamadaFuncion));
                //Comprobar que no se está llamando a un procedimiento
                aserto(llamada instanceof LlamadaFuncion,"La función debe devolver una valor");
                RESULT = new Elemento((LlamadaFuncion)llamada);
            :}
            | IDENTIFICADOR:id
            {:
                //Puede ser una variable o una constante. En ambos casos se utiliza Variable para generar el CI
                Elemento e = new Elemento();
                String name = id.getLexema();
                
                semanticErrorManager.semanticDebug("Elto. Linea: " + id.getLine() +". Valor: " + id.getLexema());
                // Comprobar que el identificador es visible desde el ámbito actual
                SymbolIF symbol = Util.comprobarExisteSimboloEnAmbito(id.getLexema(), scopeManager.getCurrentScope());
                
                e.setTipoInstruccion(symbol.getType());
                OperandIF o;
                if(symbol instanceof SymbolVariable || symbol instanceof SymbolParameter)
                {
                    o = new Variable (name, symbol);
                }else{
                    semanticErrorManager.semanticDebug("Es parametro?: " + id.getLine() +". Valor: " + id.getLexema());
                    SymbolConstant constante = (SymbolConstant)symbol;
                    o = new Value(constante.getValue());
                }
                ScopeIF scope = scopeManager.getCurrentScope();
                TemporalFactory tF = new TemporalFactory (scope);
                IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
                TemporalIF temp = tF.create ();
                e.setTemporal(temp);
                cb.addQuadruple (InstructionSetArchitecture.MOVE, temp, o);
                e.setIntermediateCode(cb.create());
                semanticErrorManager.semanticDebug(e.getIntermediateCode());
                RESULT = e;
                
            :};

sentencia ::= sentencia_asignacion:sAsig {: RESULT = sAsig;:}
            | sentencia_if:sIF {: RESULT = sIF;:}
            | sentencia_for:sFor {: RESULT = sFor;:}
            | llamada_subprograma:sub {: RESULT = new Sentencia(sub); :} 
            | sentencia_put_line:sPut {: RESULT = sPut;:}
            | RETURN expresion:exp 
            {: 
                SentenciaReturn sent = new SentenciaReturn(exp);
                sent.generarCodigoIntermedio();
                RESULT = sent;
            :}
            | error {: syntaxErrorManager.syntaxDebug ("Error en sentencia."); :};

sentencia_asignacion ::= IDENTIFICADOR:id ASIGNACION expresion:exp
                         {:
                         syntaxErrorManager.syntaxInfo("Sentencia de asignacion en linea " + id.getLine());
                         // Comprobar que el identificador es visible desde el ámbito actual
                         SymbolIF simbolo = Util.comprobarExisteSimboloEnAmbito(id.getLexema(), scopeManager.getCurrentScope());
                         
                         //Comprobar que el simbolo es una variable o un parametro
                         aserto((simbolo instanceof SymbolVariable || simbolo instanceof SymbolParameter), "El identificador a asignar debe ser una variable o un parametro: " + simbolo);
                         
                         //Comprobar que le tipo de la expresión es compatible con el del
                         // símbolo que recibe el valor en la asignación.
                         
                         
                         //syntaxErrorManager.syntaxInfo("Variable " + exp);
                         
                         //syntaxErrorManager.syntaxInfo("Variables: " + simbolo.getName() + ".\nTipos " + simbolo.getType() + " == " + exp.getTipoInstruccion());
                         //Si la expresion que asigna es una llamada a funcion, hay que comprarar los 
                         // tipos con el tipo de retorno de la funcion.
                         if(exp.getTipoInstruccion() instanceof TypeFunction)
                         {
                            aserto(simbolo.getType().getName().equals(((TypeFunction)exp.getTipoInstruccion()).getTipoRetorno().getName()), 
                            "Los tipos de la funcion (" + exp.getTipoInstruccion() + ") y de la variable asignada (" + 
                            simbolo.getType() + ") no coinciden");
                            
                         }else{
                            aserto(simbolo.getType().getName().equals(exp.getTipoInstruccion().getName()), 
                            "Los tipos de la expresion (" + exp.getTipoInstruccion() + ") y de la variable asignada (" + 
                            simbolo.getType() + ") no coinciden");
                         }
                                                  
                        Sentencia sent = new Sentencia();
                        ScopeIF scope = scopeManager.getCurrentScope();
                        TemporalFactoryIF tF = new TemporalFactory(scope);
                        TemporalIF eTemp = exp.getTemporal();
                        //TemporalIF temp = tF.create();
                        IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scope);
                        cb.addQuadruples(exp.getIntermediateCode());
                        cb.addQuadruple("MV", new Variable(id.getLexema(), simbolo), eTemp);
                        sent.setIntermediateCode(cb.create()); 
                        semanticErrorManager.semanticDebug("Sentencia asignacion: " + sent.getIntermediateCode());
                        RESULT = sent;
                         
                         
                         :}
                       | acceso_registro:reg ASIGNACION:id expresion:exp
                       {:
                            syntaxErrorManager.syntaxInfo("Asignacion a campo de registro en linea " + id.getLine());
                            AccesoRegistro accesoRegistro = (AccesoRegistro) reg;
                            
                            //Comprobar que el tipo de la expresion coincide con el del campo del registro.
                            
                            TypeBase tipo = (TypeBase)accesoRegistro.getTipoDeCampoReferenciado();
                            //semanticErrorManager.semanticInfo("Tipo del campo: " + tipo);
                            
                            aserto(tipo.getName().equals(exp.getTipoInstruccion().getName()), "Los tipos de la expresion y de la variable asignada no coinciden");
                            
                            
                            Sentencia sent = new Sentencia();
                            ScopeIF scope = scopeManager.getCurrentScope();
                            TemporalFactoryIF tF = new TemporalFactory(scope);
                            TemporalIF eTemp = exp.getTemporal();
                            TemporalIF temp = reg.getTemporal();
                            //TemporalIF temp = tF.create();
                            IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scope);
                            cb.addQuadruples(exp.getIntermediateCode());
                            cb.addQuadruple("MV", temp, eTemp);
                            sent.setIntermediateCode(cb.create()); 
                            semanticErrorManager.semanticDebug("Sentencia asignacion: " + sent.getIntermediateCode());
                            
                            
                            RESULT = sent;
                            
                       :};

sentencia_if ::= IF expresion:exp THEN lista_sentencias:lista END IF 
                {:
                    //Comprobar que la expresion sea logica
                    
                    aserto(exp instanceof ExpresionLogica, "La condición debe ser una expresión lógica.");
                    SentenciaIf sIF = new SentenciaIf(exp, lista);                    
                    sIF.generarCodigoIntermedio();
                    RESULT = sIF;
                :}
               | IF expresion:exp THEN lista_sentencias:lista1 ELSE lista_sentencias:lista2 END IF
                {:
                    //Comprobar que la expresion sea logica
                    
                    aserto(exp instanceof ExpresionLogica, "La condición debe ser una expresión lógica.");
                    
                    SentenciaIf sIF = new SentenciaIf(exp, lista1, lista2);                    
                    sIF.generarCodigoIntermedio();
                    RESULT = sIF;
                :};

sentencia_for ::= FOR expresion:exp IN expresion:exp2 PUNTOPUNTO expresion:exp3 LOOP lista_sentencias:lista END LOOP
                  {:
                     // se abre un nuevo ámbito
                    ScopeIF newScope = scopeManager.openScope();
                    
                  
                     //Comprobar que la condicion del bucle es un entero.
                    aserto(exp.getTipoInstruccion() instanceof TypeSimpleInteger, "Se esperaba un entero en la codición del bucle.");
                    
                    // comprobar que las expresiones que indican el número de iteraciones también son enteros
                    aserto(exp2.getTipoInstruccion() instanceof TypeSimpleInteger, "Se esperaba un entero en la codición del bucle");
                    aserto(exp3.getTipoInstruccion() instanceof TypeSimpleInteger, "Se esperaba un entero en la codición del bucle");
                    
                    Sentencia sFor = new Sentencia();
                    ScopeIF scope = scopeManager.getCurrentScope ();
                    LabelFactoryIF lF = new LabelFactory();
                    LabelIF l1 = lF.create ();
                    LabelIF l2 = lF.create ();
                    TemporalIF eTemp = exp3.getTemporal ();
                    IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
                    cb.addQuadruples (exp2.getIntermediateCode());
                    cb.addQuadruple (InstructionSetArchitecture.LABEL, l1);
                    cb.addQuadruples (exp3.getIntermediateCode());
                    cb.addQuadruple ("BRF", eTemp, l2);
                    cb.addQuadruples (lista.getIntermediateCode());
                    cb.addQuadruple ("BR", l1);
                    cb.addQuadruple (InstructionSetArchitecture.LABEL, l2);
                    sFor.setIntermediateCode(cb.create ());
                    RESULT = sFor;
                    
                  :}
                  | FOR sentencia_asignacion:sent IN expresion:exp2 PUNTOPUNTO expresion:exp3 LOOP lista_sentencias END LOOP
                  {:
                    // se abre un nuevo ámbito
                    ScopeIF newScope = scopeManager.openScope();
                    
                    // comprobar que las expresiones que indican el número de iteraciones también son enteros
                    aserto(exp2.getTipoInstruccion() instanceof TypeSimpleInteger, "Se esperaba un entero en la codición del bucle");
                    aserto(exp3.getTipoInstruccion() instanceof TypeSimpleInteger, "Se esperaba un entero en la codición del bucle");
                    
                  
                  :};

sentencia_put_line ::= PUT_LINE ABRE_PARENTESIS expresion:exp CIERRA_PARENTESIS
                       {:
                        //Tras la impresión en pantalla se debe generar un salto de línea.
                        //Se permite una sentencia put_line sin argumentos.
                            semanticErrorManager.semanticInfo("Sentencia put_line con expresion: " + exp);
                            SentenciaPutLine sent = new SentenciaPutLine();
                            sent.generarCodigoIntermedio(exp);
                            semanticErrorManager.semanticDebug(sent.getIntermediateCode());
                            RESULT = sent;
                       :}
                       | PUT_LINE ABRE_PARENTESIS CONSTANTE_CADENA:cad CIERRA_PARENTESIS
                       {:
                            SentenciaPutLine sent = new SentenciaPutLine();
                            sent.generarCodigoIntermedio(cad.getLexema());
                            semanticErrorManager.semanticInfo("Sentencia put_line con constante de cadena: " + sent.getIntermediateCode());
                            RESULT = sent;
                       :};

