package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.semantic.util.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();
	
	public void aserto(boolean esCierto, String mensajeError){
	
	   if(!esCierto)
	   {
	       semanticErrorManager.semanticFatalError(mensajeError);
	   }
	}

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
		Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales (Ejemplo)

terminal Token ABRE_PARENTESIS;
terminal Token ASIGNACION;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CIERRA_PARENTESIS;
terminal Token COMA;
terminal Token CONSTANT;
terminal Token CONSTANTE_CADENA;
terminal Token CONSTANTE_NUMERICA;
terminal Token DECLARACION;
terminal Token PUNTOPUNTO;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IDENTIFICADOR;
terminal Token IGUAL;
terminal Token INTEGER;
terminal Token IN;
terminal Token IF;
terminal Token IS;
terminal Token LOOP;
terminal Token MAYORQUE;
terminal Token OR;
terminal Token PLUS;
terminal Token PROCEDURE;
terminal Token PUNTO;
terminal Token PUNTOYCOMA;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
// ...


// Declaración de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
non terminal            declaraciones;
non terminal            dec_const_simbolica, dec_tipo_registro, dec_subprograma;
non terminal DecVariables dec_variables;
non terminal ListaIdentificadores lista_identificadores;
non terminal TypeSimple tipo_retorno, tipo_parametro;
non terminal Expresion  expresion, expresion_logica;
non terminal Elemento   elemento, acceso_registro;
non terminal ExpresionAritmetica expresion_aritmetica;
non terminal ParametrosFormales parametros_formales;
non terminal            funcion, procedimiento, declaraciones_subprograma;
non terminal            llamada_subprograma;
non terminal ParametrosActuales parametros_actuales;
non terminal ListaSentencias lista_sentencias;
non terminal Sentencia sentencia;
non terminal            sentencia_asignacion, sentencia_if, sentencia_for;
non terminal            sentencia_put_line;
// ...


// Declaración de relaciones de precedencia
precedence left     OR;
precedence left     IGUAL;
precedence left     MAYORQUE;
precedence left     PLUS;
precedence left     PUNTO, ABRE_PARENTESIS, CIERRA_PARENTESIS;
// ...

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Comenzando analisis..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		// Para la entrega de febrero pueden comentarse las dos sentencias siguientes:
  		 List intermediateCode = ax.getIntermediateCode ();
  		 finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest en la entrega de Febrero. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega de Junio deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Proceso de analisis terminado.");
   :};


axiom ::= PROCEDURE IDENTIFICADOR:id 
            {:
                //Crear el ámbito global del programa asociado al nombre del procedimiento.
                String name = id.getLexema();
                scopeManager.openScope(name);
                syntaxErrorManager.syntaxInfo("Ambito global " + name);
            :}
        ABRE_PARENTESIS CIERRA_PARENTESIS IS declaraciones BEGIN lista_sentencias END IDENTIFICADOR PUNTOYCOMA
        
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de procedimiento principal."); :};

declaraciones ::= dec_const_simbolica declaraciones
                | dec_variables declaraciones
                | dec_tipo_registro declaraciones
                | dec_subprograma declaraciones
                | error declaraciones{: syntaxErrorManager.syntaxDebug ("Error en declaracion."); :}  
                |;

dec_const_simbolica ::= lista_identificadores:lista DECLARACION CONSTANT ASIGNACION CONSTANTE_NUMERICA:numero PUNTOYCOMA
                        {:
                            syntaxErrorManager.syntaxInfo("Declaracion de constante");
                            // Ámbito actual
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            // Al ser una constante numérica, su tipo es entero
                            TypeIF tipo = new TypeSimpleInteger(scopeManager.getCurrentScope());
                            
                            // Añadir el tipo a la tabla de tipos
                            TypeTableIF typeTable = scope.getTypeTable();
                            if(!typeTable.containsType(tipo))
                            {
                                typeTable.addType(tipo);
                            }
                            
                            // Añadir los identificadores a la tabla de símbolos
                            List<Token> identificadores = lista.getListaIdentificadores();
                            SymbolTableIF symbolTable = scope.getSymbolTable();
                            for(int i = 0; i < identificadores.size(); i++)
                            {
                                if(!symbolTable.containsSymbol(identificadores.get(i).getLexema()))
                                {
                                    symbolTable.addSymbol(new SymbolIntegerConstant(scope, 
                                                                identificadores.get(i).getLexema(), 
                                                                tipo,
                                                                Integer.parseInt(numero.getLexema())));
                                }
                            }
                    
                        :} 
                      | lista_identificadores:lista DECLARACION CONSTANT ASIGNACION TRUE:constante PUNTOYCOMA 
                        {:
                             // Ámbito actual
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            // Al ser una constante booleana, su tipo es booleano
                            TypeIF tipo = new TypeSimpleBoolean(scopeManager.getCurrentScope());
                            
                            try{
                                Util.agregarConstanteBooleanaATablasSimbolosYTipos(scope, lista.getListaIdentificadores(), tipo, constante);
                            }catch(Exception ex)
                            {
                                semanticErrorManager.semanticFatalError(ex.getMessage());
                            }
                                                        
                        :}
                      | lista_identificadores:lista DECLARACION CONSTANT ASIGNACION FALSE:constante PUNTOYCOMA 
                        {:
                             // Ámbito actual
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            // Al ser una constante booleana, su tipo es booleano
                            TypeIF tipo = new TypeSimpleBoolean(scopeManager.getCurrentScope());
                            
                            try{
                                Util.agregarConstanteBooleanaATablasSimbolosYTipos(scope, lista.getListaIdentificadores(), tipo, constante);
                            }catch(Exception ex)
                            {
                                semanticErrorManager.semanticFatalError(ex.getMessage());
                            }
                        :};

dec_variables ::= lista_identificadores:lista DECLARACION INTEGER:id PUNTOYCOMA dec_variables
                {:
                    //registrar identificadores y devolver objeto Decvariable
                    RESULT = new DecVariables(new DecVariable(lista, new TypeSimpleInteger(scopeManager.getCurrentScope()),
                    scopeManager.getCurrentScope()));
                :} |
             lista_identificadores:lista DECLARACION IDENTIFICADOR:id PUNTOYCOMA dec_variables
                {:
                    //registrar identificadores y devolver objeto Decvariable
                    TypeIF tipo = Util.buscarTipoPreviamenteDeclarado(scopeManager, id.getLexema());
                    
                    // El tipo record debe estár declarado y ser visible en el ámbito actual
                    if(tipo == null)
                    {
                        semanticErrorManager.semanticFatalError("El tipo " + id.getLexema() + "No está declarado o no es visible en este ámbito");
                    }
                    
                    RESULT = new DecVariables(new DecVariable(lista, tipo, scopeManager.getCurrentScope()));
                :} |
             lista_identificadores:lista DECLARACION BOOLEAN:id PUNTOYCOMA dec_variables
                {:
                    //registrar identificadores y devolver objeto Decvariable
                    RESULT = new DecVariables(new DecVariable(lista, new TypeSimpleBoolean(scopeManager.getCurrentScope()),
                    scopeManager.getCurrentScope()));
                :} ;

lista_identificadores ::= IDENTIFICADOR:id COMA lista_identificadores:lista
                            {:
                                // necesito ámbito, tipo y el token identifocador (me falta el tipo!)
                                if(lista.contiene(id))
                                    semanticErrorManager.semanticFatalError("El identificador ya está declarado en el ámbito actual.");
                                lista.addIdentificador(id);
                            :} 
                        | IDENTIFICADOR:id
                            {:
                                ListaIdentificadores resultado = new ListaIdentificadores();
                                resultado.addIdentificador(id);
                                RESULT = resultado;
                            :};

dec_tipo_registro ::= TYPE IDENTIFICADOR:id IS RECORD:tipo dec_variables:declaraciones END RECORD PUNTOYCOMA 
                    {:
                        // Consultar en el ámbito actual si está el tipo resgitrado.
                        ScopeIF scope = scopeManager.getCurrentScope();
                        TypeTableIF typeTable = scope.getTypeTable();
                        TypeRecord tipoRecord = new TypeRecord(scope, id.getLexema(), declaraciones);
                        if(!typeTable.containsType(tipo.getLexema()))
                        {
                            typeTable.addType(tipoRecord);
                        }
                        SymbolTableIF symbolTable = scope.getSymbolTable();
                        if(!symbolTable.containsSymbol(id.getLexema()))
                        {
                           symbolTable.addSymbol(new SymbolVariable(scope, id, tipoRecord));
                        }
                    :};

dec_subprograma ::= funcion  
                  | procedimiento;

funcion ::= FUNCTION IDENTIFICADOR:id ABRE_PARENTESIS parametros_formales:parametros CIERRA_PARENTESIS RETURN tipo_retorno:tipoRetorno IS declaraciones_subprograma BEGIN lista_sentencias:listaSentencias END IDENTIFICADOR PUNTOYCOMA
                {:
                    // registrar la funcion en el ambito actual
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TypeFunction function = new TypeFunction(scope, id.getLexema());
                    function.setTipoRetorno(tipoRetorno);
                    Util.actualizarTablasSimbolosYTipos(scope, id, function);
                    ScopeIF newScope = scopeManager.openScope(id.getLexema());
                    function.setParametros(parametros.getParametros());
                    
                    //Registrar las declaraciones en el ambito actual
                    
                    //Comprobar que en el cuerpo existe la sentencia "return"
                    // y que su tipo coincide con el tipo de retorno declarado
                    // en la cabecera de la función.
                    if(listaSentencias.tieneSentenciaReturn())
                    {
                        SentenciaReturn sent = listaSentencias.getSentenciaReturn();
                        
                        if(sent.getTipoDevolucion() != function.getTipoRetorno())
                        {
                            semanticErrorManager.semanticFatalError("El tipo de retorno no coincide con el tipo de la sentencia Return");
                        }
                    }else{
                        semanticErrorManager.semanticFatalError("La función declarada no tiene sentencia Return");
                    }
                :};


parametros_formales ::= lista_identificadores:lista DECLARACION tipo_parametro:tipo PUNTOYCOMA parametros_formales:parametros
                        {:
                            parametros.addParametros(lista, tipo);
                        :}
                      | lista_identificadores:lista DECLARACION tipo_parametro:tipo 
                        {:
                            ParametrosFormales parametros = new ParametrosFormales();
                            parametros.addParametros(lista, tipo);
                            RESULT = parametros;
                        :}
                      | ;
                        
                       
tipo_parametro ::= INTEGER 
                        {:
                            RESULT = new TypeSimpleInteger(scopeManager.getCurrentScope());                            
                        :}
                   | BOOLEAN 
                        {:
                            new TypeSimpleBoolean(scopeManager.getCurrentScope());                            
                        :};
                        

tipo_retorno ::= INTEGER {: RESULT = new TypeSimpleInteger(scopeManager.getCurrentScope());:}
               | BOOLEAN {: RESULT = new TypeSimpleBoolean(scopeManager.getCurrentScope());:}
               | error {: syntaxErrorManager.syntaxDebug ("Error en tipo de retorno."); :};

declaraciones_subprograma ::= dec_const_simbolica declaraciones_subprograma
                            | dec_variables declaraciones_subprograma
                            | dec_subprograma declaraciones_subprograma
                            |;

procedimiento ::= PROCEDURE IDENTIFICADOR:id ABRE_PARENTESIS parametros_formales:parametros CIERRA_PARENTESIS IS declaraciones_subprograma BEGIN lista_sentencias END IDENTIFICADOR PUNTOYCOMA
                    {:
                         // registrar la funcion en el ambito actual
                        ScopeIF scope = scopeManager.getCurrentScope();
                        TypeProcedure procedure = new TypeProcedure(scope, id.getLexema());
                        Util.actualizarTablasSimbolosYTipos(scope, id, procedure);
                        ScopeIF newScope = scopeManager.openScope(id.getLexema());
                        procedure.setParametros(parametros.getParametros());
                    
                        //Registrar las declaraciones en el ambito actual
                    :};

lista_sentencias ::= sentencia PUNTOYCOMA lista_sentencias 
                   | sentencia expresion PUNTOYCOMA lista_sentencias 
                   | ;

expresion ::= expresion_aritmetica:expa {: RESULT = expa; :}
            | expresion_logica:expl {: RESULT = expl; :}
            | elemento:elto {: RESULT = elto; :}             
            | ABRE_PARENTESIS expresion:exp CIERRA_PARENTESIS {: RESULT = exp; :}
            | error PUNTOYCOMA {: syntaxErrorManager.syntaxDebug ("Error en expresion."); :};

expresion_aritmetica ::= expresion:e1 PLUS expresion:e2
        {:        
            try{
                RESULT = new ExpresionAritmetica(e1, e2);
            }catch(Exception ex){
                semanticErrorManager.semanticFatalError(ex.getMessage());
            }
        :};

expresion_logica ::= expresion:e1 IGUAL expresion:e2 
                     {:
                         try{
                                RESULT = new ExpresionLogica(e1, e2, ExpresionLogica.Operation.Eq);
                         }catch(Exception ex){
                                semanticErrorManager.semanticFatalError(ex.getMessage());
                         }
                     :}
                   | expresion:e1 OR expresion:e2
                     {:
                         try{
                                RESULT = new ExpresionLogica(e1, e2, ExpresionLogica.Operation.Or);
                         }catch(Exception ex){
                                semanticErrorManager.semanticFatalError(ex.getMessage());
                         }
                     :} 
                   | expresion:e1 MAYORQUE expresion:e2
                     {:
                         try{
                                RESULT = new ExpresionLogica(e1, e2, ExpresionLogica.Operation.Gt);
                         }catch(Exception ex){
                                semanticErrorManager.semanticFatalError(ex.getMessage());
                         }
                     :};

acceso_registro ::= IDENTIFICADOR:id PUNTO acceso_registro 
                    {:
                        // Comprobar que existe el identificador en el ambito actual
                        ScopeIF scope = scopeManager.getCurrentScope();
                        SymbolVariable variable = (SymbolVariable)Util.comprobarExisteSimboloEnAmbito(id.getLexema(), scope);
                        RESULT = new Elemento(variable);
                    :}
                  | IDENTIFICADOR:id1 PUNTO IDENTIFICADOR:id2
                    {:
                        // Comprobar que existe el identificador en el ambito actual
                        ScopeIF scope = scopeManager.getCurrentScope();
                        SymbolVariable variable = (SymbolVariable)Util.comprobarExisteSimboloEnAmbito(id1.getLexema(), scope);
                        RESULT = new Elemento(variable);
                    :};

llamada_subprograma ::= IDENTIFICADOR:id ABRE_PARENTESIS parametros_actuales:parametros CIERRA_PARENTESIS
                        {:
                            //Comprobar si elsubprograma es visible desde el ámbito actual
                            
                            TypeIF tipo = Util.buscarTipoPreviamenteDeclarado(scopeManager, id.getLexema());
                            
                            aserto(tipo != null, "El procedimiento o funcion " + id.getLexema() + " no existe");
                                                       
                            //comprobar los parametros si coinciden en orden, numero y tipo
                            TypeProcedure tipoSubprograma = (TypeProcedure)tipo;                              
                            aserto(tipoSubprograma.validarParametros(parametros.getParametros()), "Los parámetros no coinciden");                                                                
                        :};

parametros_actuales ::= expresion:exp COMA parametros_actuales:par 
                        {:
                            RESULT = new ParametrosActuales(exp, par);
                        :}
                      | expresion:exp
                        {:
                            RESULT = new ParametrosActuales(exp);
                        :}
                      |;

elemento ::= acceso_registro:reg {: RESULT = reg; :}
           | TRUE:id 
           {: RESULT = new Elemento(Util.convertirStringABoolean(id.getLexema()), new TypeSimpleBoolean(scopeManager.getCurrentScope())); :}
           | FALSE:id
           {: RESULT = new Elemento(Util.convertirStringABoolean(id.getLexema()), new TypeSimpleBoolean(scopeManager.getCurrentScope())); :}
           | CONSTANTE_NUMERICA:id
                {:
                    RESULT = new Elemento(Integer.parseInt(id.getLexema()), new TypeSimpleInteger(scopeManager.getCurrentScope()));
                :}
           | llamada_subprograma:llamada 
            {: 
                //Comprobar que no se está llamando a un procedimiento
                if(llamada instanceof Sentencia){
                    semanticErrorManager.semanticFatalError("La función debe devolver una valor");
                }    
            :};

sentencia ::= sentencia_asignacion 
            | sentencia_if 
            | sentencia_for 
            | llamada_subprograma 
            | sentencia_put_line 
            | RETURN expresion 
            | error {: syntaxErrorManager.syntaxDebug ("Error en sentencia."); :};

sentencia_asignacion ::= IDENTIFICADOR:id ASIGNACION expresion:exp
                         {:
                         syntaxErrorManager.syntaxInfo("Entencia de asignacion a " + id.getLexema());
                         // Comprobar que el identificador es visible desde el ámbito actual
                         SymbolIF simbolo = Util.comprobarExisteSimboloEnAmbito(id.getLexema(), scopeManager.getCurrentScope());
                         
                         
                         //Comprobar que le tipo de la expresión es compatible con el del
                         // símbolo que recibe el valor en la asignación.
                         
                         SymbolVariable variable = (SymbolVariable) simbolo;
                         
                         aserto(variable.getType().equals(exp.getTipoInstruccion()), "Los tipos de la expresión y de la variable asignada no coinciden");
                         
                         //Realizo la asignacion
                         variable.setValor(exp.getValue());
                         
                         :}
                       | acceso_registro:reg ASIGNACION expresion:exp
                       {:
                            //Comprobar que el tipo registro existe y es visisble desde el ámbito actual
                            
                            //Comprobar que el tipo de la expresion coincide con el del campo del registro.
                            
                            TypeBase tipo = (TypeBase)reg.getTipoInstruccion();
                            aserto(tipo.equals(exp.getTipoInstruccion()), "Los tipos de la expresión y de la variable asignada no coinciden");
                            
                            //Realiza la asignacion
                            
                            reg.setResultado(exp.getValue());
                       :};

sentencia_if ::= IF expresion:exp THEN lista_sentencias END IF 
                {:
                    //Comprobar que la expresion sea logica
                    
                    aserto(exp instanceof ExpresionLogica, "La condición debe ser una expresión lógica.");
                :}
               | IF expresion:exp THEN lista_sentencias ELSE lista_sentencias END IF
                {:
                    //Comprobar que la expresion sea logica
                    
                    aserto(exp instanceof ExpresionLogica, "La condición debe ser una expresión lógica.");
                :};

sentencia_for ::= FOR expresion:exp IN expresion:exp2 PUNTOPUNTO expresion:exp3 LOOP lista_sentencias END LOOP
                  {:
                     // se abre un nuevo ámbito
                    ScopeIF newScope = scopeManager.openScope();
                    
                  
                     //Comprobar que la condicion del bucle es un entero.
                    aserto(exp.getValue() instanceof Integer, "Se esperaba un entero en la codición del bucle");
                    
                    // comprobar que las expresiones que indican el número de iteraciones también son enteros
                    aserto(exp2.getValue() instanceof Integer, "Se esperaba un entero en la codición del bucle");
                    aserto(exp3.getValue() instanceof Integer, "Se esperaba un entero en la codición del bucle");
                    
                    
                    
                  :}
                  | FOR sentencia_asignacion:sent IN expresion:exp2 PUNTOPUNTO expresion:exp3 LOOP lista_sentencias END LOOP
                  {:
                    // se abre un nuevo ámbito
                    ScopeIF newScope = scopeManager.openScope();
                    
                    // comprobar que las expresiones que indican el número de iteraciones también son enteros
                    aserto(exp2.getValue() instanceof Integer, "Se esperaba un entero en la codición del bucle");
                    aserto(exp3.getValue() instanceof Integer, "Se esperaba un entero en la codición del bucle");
                    
                  
                  :};

sentencia_put_line ::= PUT_LINE ABRE_PARENTESIS expresion CIERRA_PARENTESIS
                       {:
                        //Tras la impresión en pantalla se debe generar un salto de línea.
                       :}
                       | PUT_LINE ABRE_PARENTESIS CONSTANTE_CADENA:cad CIERRA_PARENTESIS;

