package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.semantic.util.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();
	
	public void aserto(boolean esCierto, String mensajeError){
	
	   if(!esCierto)
	   {
	       semanticErrorManager.semanticFatalError(mensajeError);
	   }
	}
	
	   public void aserto(boolean esCierto, String mensajeError, int linea){
    
       if(!esCierto)
       {
           semanticErrorManager.semanticFatalError(mensajeError + ". Linea " + linea);
       }
    }

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
		Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales (Ejemplo)

terminal Token ABRE_PARENTESIS;
terminal Token ASIGNACION;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CIERRA_PARENTESIS;
terminal Token COMA;
terminal Token CONSTANT;
terminal Token CONSTANTE_CADENA;
terminal Token CONSTANTE_NUMERICA;
terminal Token DECLARACION;
terminal Token PUNTOPUNTO;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IDENTIFICADOR;
terminal Token IGUAL;
terminal Token INTEGER;
terminal Token IN;
terminal Token IF;
terminal Token IS;
terminal Token LOOP;
terminal Token MAYORQUE;
terminal Token OR;
terminal Token PLUS;
terminal Token PROCEDURE;
terminal Token PUNTO;
terminal Token PUNTOYCOMA;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
// ...


// Declaración de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
non terminal            declaraciones;
non terminal            dec_const_simbolica, dec_tipo_registro, dec_subprograma;
non terminal DecVariables dec_variables, dec_campos_registro;
non terminal ListaIdentificadores lista_identificadores;
non terminal TypeSimple tipo_retorno, tipo_parametro;
non terminal Expresion  expresion, expresion_logica;
non terminal Elemento   elemento;
non terminal SymbolVariable acceso_registro;
non terminal ExpresionAritmetica expresion_aritmetica;
non terminal ParametrosFormales parametros_formales;
non terminal SymbolFunction funcion;
non terminal  procedimiento, declaraciones_subprograma;
non terminal            llamada_subprograma;
non terminal ParametrosActuales parametros_actuales;
non terminal ListaSentencias lista_sentencias;
non terminal Sentencia sentencia;
non terminal            sentencia_asignacion, sentencia_if, sentencia_for;
non terminal            sentencia_put_line;
// ...


// Declaración de relaciones de precedencia
precedence left     OR;
precedence left     IGUAL;
precedence left     MAYORQUE;
precedence left     PLUS;
precedence left     PUNTO, ABRE_PARENTESIS, CIERRA_PARENTESIS;
// ...

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Comenzando analisis..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		// Para la entrega de febrero pueden comentarse las dos sentencias siguientes:
  		// List intermediateCode = ax.getIntermediateCode ();
  		// finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest en la entrega de Febrero. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega de Junio deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Proceso de analisis terminado.");
   :};


axiom ::= PROCEDURE IDENTIFICADOR:id 
            {:
                //Crear el ámbito global del programa asociado al nombre del procedimiento.
                String name = id.getLexema();
                scopeManager.openScope(name);
                syntaxErrorManager.syntaxInfo("Ambito global " + name);
            :}
        ABRE_PARENTESIS CIERRA_PARENTESIS IS declaraciones BEGIN
        {: syntaxErrorManager.syntaxInfo("Comienza cuerpo programa");:} 
        lista_sentencias 
        {: syntaxErrorManager.syntaxInfo("Termina cuerpo programa");:}
        END IDENTIFICADOR PUNTOYCOMA
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de procedimiento principal."); :};

declaraciones ::= dec_const_simbolica declaraciones
                | dec_variables declaraciones
                | dec_tipo_registro declaraciones
                | dec_subprograma declaraciones
                | error declaraciones {: syntaxErrorManager.syntaxDebug ("Error en declaracion."); :}  
                | {: syntaxErrorManager.syntaxInfo("Fin declaraciones"); :};

dec_const_simbolica ::= lista_identificadores:lista DECLARACION CONSTANT ASIGNACION CONSTANTE_NUMERICA:numero PUNTOYCOMA
                        {:
                            semanticErrorManager.semanticInfo("Declaracion de constantes numericas en linea " + numero.getLine());
                            // Ámbito actual
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            // Al ser una constante numérica, su tipo es entero
                            TypeIF tipo = new TypeSimpleInteger(scopeManager.getCurrentScope());
                            
                            // Añadir el tipo a la tabla de tipos
                            TypeTableIF typeTable = scope.getTypeTable();
                            if(!typeTable.containsType(tipo))
                            {
                                typeTable.addType(tipo);
                            }
                            
                            // Añadir los identificadores a la tabla de símbolos
                            List<Token> identificadores = lista.getListaIdentificadores();
                            SymbolTableIF symbolTable = scope.getSymbolTable();
                            for(int i = 0; i < identificadores.size(); i++)
                            {
                                if(!symbolTable.containsSymbol(identificadores.get(i).getLexema()))
                                {
                                    symbolTable.addSymbol(new SymbolIntegerConstant(scope, 
                                                                identificadores.get(i).getLexema(), 
                                                                tipo,
                                                                Integer.parseInt(numero.getLexema())));
                                }
                            }
                             
                        :} 
                      | lista_identificadores:lista DECLARACION CONSTANT ASIGNACION TRUE:constante PUNTOYCOMA 
                        {:
                        semanticErrorManager.semanticInfo("Declaracion de constantes con valor true en linea " + constante.getLine());
                            
                             // Ámbito actual
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            // Al ser una constante booleana, su tipo es booleano
                            TypeIF tipo = new TypeSimpleBoolean(scopeManager.getCurrentScope());
                            
                            Util.agregarConstanteBooleanaATablasSimbolosYTipos(scope, lista.getListaIdentificadores(), tipo, constante);
                        :}
                      | lista_identificadores:lista DECLARACION CONSTANT ASIGNACION FALSE:constante PUNTOYCOMA 
                        {:
                            semanticErrorManager.semanticInfo("Declaracion de constantes con valor false en linea " + constante.getLine());
                            
                             // Ámbito actual
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            // Al ser una constante booleana, su tipo es booleano
                            TypeIF tipo = new TypeSimpleBoolean(scopeManager.getCurrentScope());
                            
                            Util.agregarConstanteBooleanaATablasSimbolosYTipos(scope, lista.getListaIdentificadores(), tipo, constante);
                        :};

dec_campos_registro ::= dec_variables:dec dec_campos_registro:dec_reg 
                        {:
                            for(DecVariable decVar : dec.getDeclaraciones())
                            {
                                dec_reg.addDeclaracion(decVar);
                            }
                            RESULT = dec_reg;
                        :}
                        | dec_variables:dec
                        {:
                            RESULT = dec;
                        :};

dec_variables ::= lista_identificadores:lista DECLARACION INTEGER:id PUNTOYCOMA 
                {:
                    syntaxErrorManager.syntaxInfo("Declaracion de variables de tipo entero. Linea " + id.getLine());
                    // comprobar si ya hay una variable con el mismo nombre en el ambito actual
                    // El objeto DecVariable hace la comprobación.
                    //registrar identificadores y devolver objeto Decvariable
                    RESULT = new DecVariables(new DecVariable(lista, new TypeSimpleInteger(scopeManager.getCurrentScope()),
                    scopeManager.getCurrentScope()));
                :} |
             lista_identificadores:lista DECLARACION IDENTIFICADOR:id PUNTOYCOMA 
                {:
                    //registrar identificadores y devolver objeto Decvariable
                    TypeIF tipo = Util.buscarTipoPreviamenteDeclarado(scopeManager, id.getLexema());
                    
                    // El tipo record debe estár declarado y ser visible en el ámbito actual
                    aserto(tipo != null, "El tipo " + id.getLexema() + " no esta declarado o no es visible en este ambito", id.getLine());
                                        
                    RESULT = new DecVariables(new DecVariable(lista, tipo, scopeManager.getCurrentScope()));
                :} |
             lista_identificadores:lista DECLARACION BOOLEAN:id PUNTOYCOMA 
                {:
                    //registrar identificadores y devolver objeto Decvariable
                    RESULT = new DecVariables(new DecVariable(lista, new TypeSimpleBoolean(scopeManager.getCurrentScope()),
                    scopeManager.getCurrentScope()));
                :};

lista_identificadores ::= IDENTIFICADOR:id COMA lista_identificadores:lista
                            {:
                                //syntaxErrorManager.syntaxInfo("Varios identificadores, " + id.getLexema());
                                // necesito ámbito, tipo y el token identifocador (me falta el tipo!)
                                aserto(!lista.contiene(id), "El identificador " + id.getLexema() + " ya está declarado en el ámbito actual. linea " + id.getLine());
                                lista.addIdentificador(id);
                                RESULT = lista;
                            :} 
                        | IDENTIFICADOR:id
                            {:
                                //syntaxErrorManager.syntaxInfo("Un solo identificador, " + id.getLexema());
                                ListaIdentificadores resultado = new ListaIdentificadores();
                                resultado.addIdentificador(id);
                                RESULT = resultado;
                                //syntaxErrorManager.syntaxInfo("Fin lista_identificadores, " + id.getLexema());
                            :};

dec_tipo_registro ::= TYPE IDENTIFICADOR:id IS RECORD
{:
                        syntaxErrorManager.syntaxInfo("Declaracion de registro " + id.getLexema() + ". Linea " + id.getLine());
                    :}
 dec_campos_registro:declaraciones END RECORD PUNTOYCOMA 
                    {:
                        syntaxErrorManager.syntaxInfo("Declaracion de registro " + id.getLexema() + ". Linea " + id.getLine());
                    
                        // Consultar en el ámbito actual si está el tipo resgitrado.
                        ScopeIF scope = scopeManager.getCurrentScope();
                        TypeTableIF typeTable = scope.getTypeTable();
                        TypeRecord tipoRecord = new TypeRecord(scope, id.getLexema(), declaraciones);
                        aserto(!typeTable.containsType(id.getLexema()), "El tipo ya esta declarado. Linea " + id.getLine());
                        semanticErrorManager.semanticInfo("Agergo el tipo " + id.getLexema() + " a la tabla de tipos del ambito " + scope);
                        typeTable.addType(tipoRecord);
                        
                        //SymbolTableIF symbolTable = scope.getSymbolTable();
                        //if(!symbolTable.containsSymbol(id.getLexema()))
                        //{
                        //   symbolTable.addSymbol(new SymbolVariable(scope, id, tipoRecord));
                        //}
                    :};

dec_subprograma ::= funcion  
                  | procedimiento;

funcion ::= FUNCTION IDENTIFICADOR:id ABRE_PARENTESIS parametros_formales:parametros CIERRA_PARENTESIS RETURN tipo_retorno:tipoRetorno
            {:
                syntaxErrorManager.syntaxInfo("Linea " + id.getLine() + ". Declaracion de funcion " + id.getLexema());
                   //Abrir ambito de la funcion
                    scopeManager.openScope(id.getLexema());
            :} 
            IS declaraciones_subprograma BEGIN lista_sentencias:listaSentencias END IDENTIFICADOR PUNTOYCOMA
                {:
                     // registrar la funcion en el ambito actual
                    ScopeIF scope = scopeManager.getCurrentScope();
                                        
                    //Registrar las declaraciones en el ambito actual
                    
                    TypeFunction function;
                    
                    if(parametros != null)
                    {
                        function = new TypeFunction(scope, id.getLexema(), parametros.getParametros());
                    }else{
                        function = new TypeFunction(scope, id.getLexema());
                    }
                    function.setTipoRetorno(tipoRetorno);
                    TypeTableIF typeTable = scope.getTypeTable();
                    if(!typeTable.containsType(function))
                    {
                        typeTable.addType(function);
                    }
                    //Registrar e el ambito las declaraciones
                    
                    //Comprobar que en el cuerpo existe la sentencia "return"
                    syntaxErrorManager.syntaxInfo("Declaracion de funcion  " + id.getLexema() + " , listaSentencias: " + listaSentencias);
                    aserto(listaSentencias != null, "La función declarada no tiene sentencia Return");
                    aserto(listaSentencias.tieneSentenciaReturn(), "La funcion declarada no tiene sentencia Return");
                    
                    SentenciaReturn sent = listaSentencias.getSentenciaReturn();
                    aserto(sent != null, "La funcion declarada no tiene sentencia Return");
                    // Comprobar que su tipo coincide con el tipo de retorno declarado
                    // en la cabecera de la función.
                    aserto(sent.getTipoDevolucion() != function.getTipoRetorno(), "El tipo de retorno no coincide con el tipo de la sentencia Return");
                    
                    scopeManager.closeScope();
                   
                :};


parametros_formales ::= lista_identificadores:lista DECLARACION tipo_parametro:tipo PUNTOYCOMA parametros_formales:parametros
                        {:
                        syntaxErrorManager.syntaxInfo("Declaracion de parametros formales");
                            parametros.addParametros(lista, tipo);
                            RESULT = parametros;
                        :}
                      | lista_identificadores:lista DECLARACION tipo_parametro:tipo 
                        {:
                            syntaxErrorManager.syntaxInfo("Declaracion de parametro formal");
                            ParametrosFormales parametros = new ParametrosFormales(lista, tipo);
                            RESULT = parametros;
                            syntaxErrorManager.syntaxInfo("Fin Declaracion de parametro formal");
                        :}
                      | ;
                        
                       
tipo_parametro ::= INTEGER 
                        {:
                            RESULT = new TypeSimpleInteger(scopeManager.getCurrentScope());                            
                        :}
                   | BOOLEAN 
                        {:
                            RESULT = new TypeSimpleBoolean(scopeManager.getCurrentScope());                            
                        :};
                        

tipo_retorno ::= INTEGER {: RESULT = new TypeSimpleInteger(scopeManager.getCurrentScope());:}
               | BOOLEAN {: RESULT = new TypeSimpleBoolean(scopeManager.getCurrentScope());:}
               | error {: syntaxErrorManager.syntaxDebug ("Error en tipo de retorno."); :};

declaraciones_subprograma ::= dec_const_simbolica declaraciones_subprograma
                            | dec_variables declaraciones_subprograma
                            | dec_subprograma declaraciones_subprograma
                            |;

procedimiento ::= PROCEDURE IDENTIFICADOR:id ABRE_PARENTESIS parametros_formales:parametros CIERRA_PARENTESIS IS declaraciones_subprograma BEGIN lista_sentencias END IDENTIFICADOR PUNTOYCOMA
                    {:
                         // registrar la funcion en el ambito actual
                        ScopeIF scope = scopeManager.getCurrentScope();
                        TypeProcedure procedure = new TypeProcedure(scope, id.getLexema(), parametros.getParametros());
                        Util.actualizarTablasSimbolosYTipos(scope, id, procedure);
                        ScopeIF newScope = scopeManager.openScope(id.getLexema());
                        //procedure.setParametros(parametros.getParametros());
                    
                        //Registrar las declaraciones en el ambito actual
                    :};

lista_sentencias ::= sentencia:sent PUNTOYCOMA lista_sentencias:lista
                    {: 
                    
                        syntaxErrorManager.syntaxInfo("Lista de sentenciass. lista es " + lista + ". Sentencia es " + sent); 
                        //Agregar la sentencia a la lista de sentencias
                        
                        if(lista == null){
                            lista = new ListaSentencias();
                        }
                            
                        if(sent != null){
                            lista.agregarSentenciaOExpresion(sent);
                        }
                        RESULT = lista;
                    
                    :}
                   | sentencia:sent expresion:exp PUNTOYCOMA lista_sentencias:lista 
                    {: 
                    
                        syntaxErrorManager.syntaxInfo("Lista de sentencias. lista es " + lista + ". Sentencia es " + sent); 
                        //Agregar la sentencia a la lista de sentencias
                        if(lista == null){
                            lista = new ListaSentencias();
                        }
                        if(sent != null){
                            lista.agregarSentenciaOExpresion(sent);
                        }
                        if(exp != null){
                            lista.agregarSentenciaOExpresion(exp);
                        }
                        RESULT = lista;
                    
                    :}
                   | ;

expresion ::= expresion_aritmetica:expa {: RESULT = expa; :}
            | expresion_logica:expl {: RESULT = expl; :}
            | elemento:elto {: RESULT = elto; :}             
            | ABRE_PARENTESIS expresion:exp CIERRA_PARENTESIS {: RESULT = exp; :}
            | error PUNTOYCOMA {: syntaxErrorManager.syntaxDebug ("Error en expresion."); :};

expresion_aritmetica ::= expresion:e1 PLUS expresion:e2
        {:        
            syntaxErrorManager.syntaxInfo("Expresion aritmetica");
            RESULT = new ExpresionAritmetica(e1, e2);            
        :};

expresion_logica ::= expresion:e1 IGUAL expresion:e2 
                     {:
                         RESULT = new ExpresionLogica(e1, e2, ExpresionLogica.Operation.Eq);
                     :}
                   | expresion:e1 OR expresion:e2
                     {:
                         RESULT = new ExpresionLogica(e1, e2, ExpresionLogica.Operation.Or);
                     :} 
                   | expresion:e1 MAYORQUE expresion:e2
                     {:
                         RESULT = new ExpresionLogica(e1, e2, ExpresionLogica.Operation.Gt);
                     :};

acceso_registro ::= IDENTIFICADOR:id PUNTO acceso_registro:acreg
                    {:
                        semanticErrorManager.semanticInfo("Acceso a registro dentro de registro " + id.getLexema());
                        // Comprobar que existe el identificador en el ambito actual
                        ScopeIF scope = scopeManager.getCurrentScope();
                        SymbolVariable variable = (SymbolVariable)Util.comprobarExisteSimboloEnAmbito(id.getLexema(), scope);
                        
                        SymbolVariableRecord accesoRegistro = (SymbolVariableRecord)acreg;
                        semanticErrorManager.semanticInfo("Acceso a registro dentro de registro " + variable.getType());
                        //El tipo en este caso debe ser TypeRecord
                        aserto(variable.getType() instanceof TypeRecord, "La variable " + variable.getName() + "no no es de tipo registro.", id.getLine());
                        //RESULT = new SymbolVariableRecord(variable, accesoRegistro.getCampoReferenciado().getName());
                        RESULT = accesoRegistro;
                    :}
                  | IDENTIFICADOR:id1 PUNTO IDENTIFICADOR:id2
                    {:
                        // Comprobar que existe el identificador en el ambito actual
                        ScopeIF scope = scopeManager.getCurrentScope();
                        SymbolVariable variable = (SymbolVariable)Util.comprobarExisteSimboloEnAmbito(id1.getLexema(), scope);
                        aserto(variable.getType() != null, "El tipo es nuloooooooooooooooooooooooooo " + variable);
                        
                        // Crear objeto SymbolVariableRecord indicando el campo del registro que se esta referenciando.
                        RESULT = new SymbolVariableRecord(variable, id2.getLexema());
                    :};

llamada_subprograma ::= IDENTIFICADOR:id ABRE_PARENTESIS parametros_actuales:parametros CIERRA_PARENTESIS
                        {:
                            syntaxErrorManager.syntaxInfo("Llamada al subprograma " + id.getLexema());
                            //Comprobar si elsubprograma es visible desde el ámbito actual
                            
                            TypeIF tipo = Util.buscarTipoPreviamenteDeclarado(scopeManager, id.getLexema());
                            
                            aserto(tipo != null, "El procedimiento o funcion " + id.getLexema() + " no existe");
                                                       
                            //comprobar los parametros si coinciden en orden, numero y tipo
                            TypeProcedure tipoSubprograma = (TypeProcedure)tipo;                              
                            aserto(tipoSubprograma.validarParametros(parametros.getParametros()), "Los parámetros no coinciden");
                            if(tipoSubprograma instanceof TypeFunction)
                            {
                                RESULT = new SymbolFunction(scopeManager.getCurrentScope(), id.getLexema(), tipo);
                            }else{
                                RESULT = new SymbolProcedure(scopeManager.getCurrentScope(), id.getLexema(), tipo);
                            }
                                                                                             
                        :};

parametros_actuales ::= expresion:exp COMA parametros_actuales:par 
                        {:
                            RESULT = new ParametrosActuales(exp, par);
                        :}
                      | expresion:exp
                        {:
                            RESULT = new ParametrosActuales(exp);
                        :}
                      |;

elemento ::= acceso_registro:reg {: RESULT = new Elemento(reg); :}
           | TRUE:id 
           {: RESULT = new Elemento(Util.convertirStringABoolean(id.getLexema()), new TypeSimpleBoolean(scopeManager.getCurrentScope())); :}
           | FALSE:id
           {: RESULT = new Elemento(Util.convertirStringABoolean(id.getLexema()), new TypeSimpleBoolean(scopeManager.getCurrentScope())); :}
           | CONSTANTE_NUMERICA:id
                {:
                syntaxErrorManager.syntaxInfo("Cte numerica");
                    RESULT = new Elemento(Integer.parseInt(id.getLexema()), new TypeSimpleInteger(scopeManager.getCurrentScope()));
                :}
           | llamada_subprograma:llamada 
            {: 
                syntaxErrorManager.syntaxInfo("Llamada subprograma " + (llamada instanceof SymbolFunction));
                //Comprobar que no se está llamando a un procedimiento
                aserto(llamada instanceof SymbolFunction,"La función debe devolver una valor");
                RESULT = new Elemento((SymbolIF)llamada);
            :}
            | IDENTIFICADOR:id
            {:
                 
                // Comprobar que el identificador es visible desde el ámbito actual
                SymbolIF simbolo = Util.comprobarExisteSimboloEnAmbito(id.getLexema(), scopeManager.getCurrentScope());
                RESULT = new Elemento(simbolo);
                
            :};

sentencia ::= sentencia_asignacion 
            | sentencia_if 
            | sentencia_for 
            | llamada_subprograma 
            | sentencia_put_line 
            | RETURN expresion:exp {: RESULT = new SentenciaReturn(exp);:}
            | error {: syntaxErrorManager.syntaxDebug ("Error en sentencia."); :};

sentencia_asignacion ::= IDENTIFICADOR:id ASIGNACION expresion:exp
                         {:
                         syntaxErrorManager.syntaxInfo("Sentencia de asignacion en linea " + id.getLine());
                         // Comprobar que el identificador es visible desde el ámbito actual
                         SymbolIF simbolo = Util.comprobarExisteSimboloEnAmbito(id.getLexema(), scopeManager.getCurrentScope());
                         
                         //Comprobar que el simbolo es una variable
                         aserto(simbolo instanceof SymbolVariable, "El identificador a asignar debe ser una variable: " + simbolo);
                         
                         //Comprobar que le tipo de la expresión es compatible con el del
                         // símbolo que recibe el valor en la asignación.
                         
                         SymbolVariable variable = (SymbolVariable) simbolo;
                         syntaxErrorManager.syntaxInfo("Variable " + exp);
                         
                         syntaxErrorManager.syntaxInfo("Variables: " + variable.getName() + " valor: " + exp.getValue() + ".\nTipos " + variable.getType() + " == " + exp.getTipoInstruccion());
                         //Si la expresion que asigna es una llamada a funcion, hay que comprarar los 
                         // tipos con el tipo de retorno de la funcion.
                         if(exp.getTipoInstruccion() instanceof TypeFunction)
                         {
                            aserto(variable.getType().getName().equals(((TypeFunction)exp.getTipoInstruccion()).getTipoRetorno().getName()), 
                            "Los tipos de la funcion (" + exp.getTipoInstruccion() + ") y de la variable asignada (" + 
                            variable.getType() + ") no coinciden");
                         }else{
                            aserto(variable.getType().getName().equals(exp.getTipoInstruccion().getName()), 
                            "Los tipos de la expresion (" + exp.getTipoInstruccion() + ") y de la variable asignada (" + 
                            variable.getType() + ") no coinciden");
                         }
                         //Realizo la asignacion
                         variable.setValor(exp.getValue());
                         
                         :}
                       | acceso_registro:reg ASIGNACION:id expresion:exp
                       {:
                            syntaxErrorManager.syntaxInfo("Asignacion a campo de registro en linea " + id.getLine());
                            //Comprobar que el tipo registro existe y es visisble desde el ámbito actual
                            syntaxErrorManager.syntaxInfo("Tipo del registrooo " + reg.getType());
                            SymbolVariableRecord accesoRegistro = (SymbolVariableRecord) reg;
                            
                            //Comprobar que el tipo de la expresion coincide con el del campo del registro.
                            
                            TypeBase tipo = (TypeBase)accesoRegistro.getTipoDeCampoReferenciado();
                            semanticErrorManager.semanticInfo("Tipo del campo: " + tipo);
                            
                            aserto(tipo.getName().equals(exp.getTipoInstruccion().getName()), "Los tipos de la expresion y de la variable asignada no coinciden");
                            
                            //Realiza la asignacion
                            
                            
                       :};

sentencia_if ::= IF expresion:exp THEN lista_sentencias END IF 
                {:
                    //Comprobar que la expresion sea logica
                    
                    aserto(exp instanceof ExpresionLogica, "La condición debe ser una expresión lógica.");
                :}
               | IF expresion:exp THEN lista_sentencias ELSE lista_sentencias END IF
                {:
                    //Comprobar que la expresion sea logica
                    
                    aserto(exp instanceof ExpresionLogica, "La condición debe ser una expresión lógica.");
                :};

sentencia_for ::= FOR expresion:exp IN expresion:exp2 PUNTOPUNTO expresion:exp3 LOOP lista_sentencias END LOOP
                  {:
                     // se abre un nuevo ámbito
                    ScopeIF newScope = scopeManager.openScope();
                    
                  
                     //Comprobar que la condicion del bucle es un entero.
                    aserto(exp.getValue() instanceof Integer, "Se esperaba un entero en la codición del bucle");
                    
                    // comprobar que las expresiones que indican el número de iteraciones también son enteros
                    aserto(exp2.getValue() instanceof Integer, "Se esperaba un entero en la codición del bucle");
                    aserto(exp3.getValue() instanceof Integer, "Se esperaba un entero en la codición del bucle");
                    
                    
                    
                  :}
                  | FOR sentencia_asignacion:sent IN expresion:exp2 PUNTOPUNTO expresion:exp3 LOOP lista_sentencias END LOOP
                  {:
                    // se abre un nuevo ámbito
                    ScopeIF newScope = scopeManager.openScope();
                    
                    // comprobar que las expresiones que indican el número de iteraciones también son enteros
                    aserto(exp2.getValue() instanceof Integer, "Se esperaba un entero en la codición del bucle");
                    aserto(exp3.getValue() instanceof Integer, "Se esperaba un entero en la codición del bucle");
                    
                  
                  :};

sentencia_put_line ::= PUT_LINE ABRE_PARENTESIS expresion CIERRA_PARENTESIS
                       {:
                        //Tras la impresión en pantalla se debe generar un salto de línea.
                        //Se permite una sentencia put_line sin argumentos.
                       :}
                       | PUT_LINE ABRE_PARENTESIS CONSTANTE_CADENA:cad CIERRA_PARENTESIS;

